<html>
    <head>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>

        <!-- https://docs.agora.io/en/Video/start_call_web?platform=Web -->
        <script src='https://cdn.agora.io/sdk/release/AgoraRTCSDK-3.1.0.js'></script>

        <!-- https://github.com/davidshimjs/qrcodejs -->
        <script src='https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js'></script>

        <meta charset="utf-8">
        <script src="https://croquet.io/sdk/croquet-latest.min.js"></script>

        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    </head>

    <style>
        html, body {
            font-family: 'Open Sans', sans-serif;
        }
    </style>

    <script data-script='https'>
        if(location.protocol !== 'https:')
            location.replace(`https:${location.href.substring(location.protocol.length)}`)
    </script>

    <script data-script='logger'>
        AgoraRTC.Logger.setLogLevel(AgoraRTC.Logger.NONE);
    </script>

    <script data-script='StreamMixerInput'>
        class StreamMixerInput {
            constructor(stream, audioContext, mediaStreamDestination, streamMixer) {
                if(stream.getVideoTracks().length) {
                    this._alpha = 0;

                    this.streamMixer = streamMixer;

                    this.video = document.createElement('video');
                    this.video.playsInline = true;
                    this.video.muted = true;
                    this.video.autoplay = true;
                    this.video.onloadedmetadata = () => this.updateVideoDimensions();
                    this.video.srcObject = stream;
                    this.video.play();

                    this.alphaTransitionTime = 250;

                    document.addEventListener('click', () => this.video.play(), {once: true});
                }

                if(stream.getAudioTracks().length) {
                    this.audioContext = audioContext;

                    this.mediaStreamSource = audioContext.createMediaStreamSource(stream);
                    
                    this.gainNode = audioContext.createGain();
                    this.gainNode.gain.value = 0;

                    this.gainTransitionTime = 0.1;

                    this.mediaStreamSource.connect(this.gainNode).connect(mediaStreamDestination);
                }
            }

            get hasVideo() {
                return Boolean(this.video);
            }

            get hasAudio() {
                return Boolean(this.mediaStreamSource);
            }

            get stream() {
                if(this.video)
                    return this.video.srcObject;
                else
                    return this.mediaStreamSource.mediaStream;
            }

            updateVideoDimensions() {
                if(this.video) {
                    const {width, height} = this.video.srcObject.getVideoTracks()[0].getSettings();
                    this.video.width = width;
                    this.video.height = height;

                    if(this.isVideoMuted) {
                        this.streamMixer.aspectRatio = width/height;
                    }
                }
            }

            get alpha() {
                return this._alpha;
            }
            set alpha(alpha) {
                if(alpha > 0)
                    delete this.__alpha;
                                
                if(!isNaN(this.intervalId)) {
                    this._alpha = this._alphaTarget;
                    delete this._alphaTarget;

                    if(this.isVideoMuted)
                        this.__alpha = this._alpha;

                    clearInterval(this.intervalId);
                    delete this.intervalId;
                }

                const now = Date.now();
                const fromAlpha = this.alpha;
                this._alphaTarget = alpha;
                this.intervalId = window.setInterval(() => {
                    const interpolation = ((Date.now() - now)/this.alphaTransitionTime);
                    const interpolatedAlpha = ((1-interpolation) * fromAlpha) + (interpolation * alpha);
                    this._alpha = Math.max(0, Math.min(1, interpolatedAlpha));
                    
                    if(interpolation >= 1) {
                        window.clearInterval(this.intervalId);
                        delete this.intervalId;
                    }
                }, 100);
            }

            muteVideo() {
                if(!this.isVideoMuted) {
                    this.__alpha = this.alpha;
                    this.alpha = 0;
                }
            }
            get isVideoMuted() {
                return !isNaN(this.__alpha);
            }
            unmuteVideo() {
                if(this.isVideoMuted) {
                    this.alpha = this.__alpha;
                    delete this.__alpha;
                }
            }

            draw(canvas, context) {
                if(this.video) {
                    context.save();

                    context.globalAlpha = this.alpha;
                    this.drawImage(canvas, context);

                    context.restore();
                }
            }

            drawImage(canvas, context) {
                if(this.alpha) {
                    const {width, height} = this.video.srcObject.getVideoTracks()[0].getSettings();
                    this.video.width = width;
                    this.video.height = height;

                    const aspectRatio = width/height;
                    if(this.alpha == 1 && Math.abs(aspectRatio - this.streamMixer.aspectRatio) > 0.1)
                        this.streamMixer.aspectRatio = aspectRatio;

                    context.drawImage(this.video, 0, 0, width, height, 0, 0, canvas.width, canvas.height);
                }
            }

            connect() {
                if(this.gainNode)
                    this.gainNode.connect(...arguments);
            }
            disconnect() {
                if(this.gainNode)
                    this.gainNode.disconnect(...arguments);
            }

            get gain() {
                if(this.gainNode)
                    return this.gainNode.gain.value;
            }
            set gain(gain) {
                if(this.gainNode) {
                    if(gain > 0)
                        delete this.__gain;
                    this.gainNode.gain.value = gain;
                }
            }

            muteAudio() {
                if(!this.isAudioMuted) {
                    this.__gain = this.gain;
                    this.gain = 0;
                }
            }
            get isAudioMuted() {
                return !isNaN(this.__gain);
            }
            unmuteAudio() {
                if(this.isAudioMuted) {
                    this.gain = this.__gain;
                    delete this.__gain;
                }
            }

            remove() {
                this.disconnect();
                this.gain = 0;
                this.alpha = 0;

                if(this.video)
                    this.video.srcObject = null;
            }
        }
    </script>

    <script data-script='StreamMixer'>
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let mixerView;
        class StreamMixer {
            constructor() {
                this.inputs = [];

                this._canvases = [];

                this.canvas = document.createElement('canvas');
                this.canvas.classList.add('video')
                this.canvasContext = this.canvas.getContext('2d');
                this.length = 200;

                /*
                window.addEventListener('load', event => {
                    this.canvas.style.display = 'none';
                    document.body.appendChild(this.canvas);
                });
                */

                this.audioContext = new AudioContext();
                document.addEventListener('click', () => this.audioContext.resume(), {once: true});
                this.mediaStreamDestination = this.audioContext.createMediaStreamDestination();

                this.videoStream = this.canvas.captureStream(100);
                this.audioStream = this.mediaStreamDestination.stream;

                this.frameRate = 12;
                this.startDrawing();
            }

            get aspectRatio() {
                return this.canvas.width/this.canvas.height;
            }

            set aspectRatio(aspectRatio) {
                this.canvas.height = this.canvas.width/aspectRatio;
                this.updateSize();
            }
            
            get width() {
                return this.canvas.width;
            }
            set width(width) {
                if(this.canvas.width !== width) return;

                this.canvas.height = width/this.aspectRatio;
                this.canvas.width = width;
                this.updateSize();
            }

            get height() {
                return this.canvas.height;
            }
            set height(height) {
                if(this.canvas.height !== height) return;

                this.canvas.height = height;
                this.canvas.width = height*this.aspectRatio;
                this.updateSize();
            }

            get length() {
                return Math.max(this.canvas.width, this.canvas.height);
            }
            set length(length) {
                if(this.aspectRatio >= 1)
                    this.width = length;
                else
                    this.height = length;
            }

            addCanvas(canvas) {
                canvas.width = this.width;
                canvas.height = this.height;
                this._canvases.push(canvas);
            }
            removeCanvas(canvas) {
                if(this._canvases.includes(canvas))
                    this._canvases.splice(this._canvases.indexOf(canvas), 1);
            }

            get videoInputs() {
                return this.inputs.filter(input => input.hasVideo);
            }
            
            get audioInputs() {
                return this.inputs.filter(input => input.hasAudio);
            }

            getInputByStream(stream) {
                return this.inputs.find(input => input.stream == stream);
            }

            updateSize() {
                //if((Date.now() - this._updateSizeTimestamp) < 10) return;
                //this._updateSizeTimestamp = Date.now();

                this._canvases.forEach(canvas => {
                    canvas.width = this.width;
                    canvas.height = this.height;
                });
                this.draw();
            }

            get frameRate() {
                return this._frameRate;
            }
            set frameRate(frameRate) {
                this._frameRate = frameRate;

                if(this.isDrawing)
                    this.startDrawing();
            }

            startDrawing() {
                this.stopDrawing();
                this.intervalId = window.setInterval(() => {
                    this.draw();
                }, 1000/this.frameRate);
            }

            get isDrawing() {
                return !isNaN(this.intervalId);
            }

            draw() {
                this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.videoInputs.forEach(input => input.draw(this.canvas, this.canvasContext));
                //this.videoStream.getVideoTracks()[0].requestFrame();

                if(this.canvas.width == 0 || this.canvas.width == 0) return;

                this._canvases.forEach(canvas => {
                    const context = canvas.getContext('2d');
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.drawImage(this.canvas, 0, 0);
                });
            }

            stopDrawing() {
                if(this.isDrawing) {
                    window.clearInterval(this.intervalId);
                    delete this.intervalId;
                }
            }

            addStream(stream) {
                let input = this.getInputByStream(stream);
                if(!input) {
                    input = new StreamMixerInput(stream, this.audioContext, this.mediaStreamDestination, this);
                    this.inputs.push(input);
                }
            }

            removeStream(stream) {
                let input = this.getInputByStream(stream);
                if(input) {
                    input.remove();
                    this.inputs.splice(this.inputs.indexOf(input), 1);
                }
            }

            setAlpha(stream, alpha) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.alpha = alpha;
            }
            setGain(stream, gain) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.gain = gain;
            }

            muteAudio(stream) {
                const input = this.getInputByStream(stream);
                if(input && input.hasAudio)
                    input.muteAudio();
            }
            unmuteAudio(stream) {
                const input = this.getInputByStream(stream);
                if(input && input.hasAudio)
                    input.unmuteAudio();
            }

            muteVideo(stream) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.muteVideo();
            }
            unmuteVideo(stream) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.unmuteVideo();
            }

            soloVideo(stream) {
                if(stream.getVideoTracks()[0]) {
                    const {width, height} = stream.getVideoTracks()[0].getSettings();
                    this.width = width;
                    this.height = height;
                }

                this.videoInputs.forEach(videoInput => {
                    if(videoInput.stream == stream) {
                        const {width, height} = videoInput.stream.getVideoTracks()[0].getSettings();
                        if(width > 0 && height > 0) {
                            this.aspectRatio = width/height;
                        }
                        videoInput.unmuteVideo();
                    }
                    else
                        videoInput.muteVideo();
                });
            }
            soloAudio(stream) {
                this.audioInputs.forEach(audioInput => {
                    if(audioInput.stream == stream)
                        audioInput.unmuteAudio();
                    else
                        audioInput.muteAudio();
                });
            }
            solo(stream) {
                this.soloVideo(stream);
                this.soloAudio(stream);
            }
        }
    </script>

    <script data-script='streamMixer'>
        const streamMixer = new StreamMixer();
        document.addEventListener('localstreams', event => {
            if(localStreams.video) {
                streamMixer.addStream(localStreams.video);

                streamMixer.setAlpha(localStreams.video, 1);
                streamMixer.soloVideo(localStreams.video);
            }

            if(localStreams.audio) {
                streamMixer.addStream(localStreams.audio);

                streamMixer.setGain(localStreams.audio, 1);
                streamMixer.soloAudio(localStreams.audio);
            }

            window.dispatchEvent(new Event('resize'));
        });
        document.addEventListener('mixer-stream-subscribed', event => {
            const _stream = event.detail.stream;
            streamMixer.addStream(_stream.stream);
            streamMixer.setAlpha(_stream.stream, 1);
            streamMixer.soloVideo(_stream.stream);

            //streamMixer.setGain(_stream.stream, 1);
            //streamMixer.soloAudio(_stream.stream);

            setTimeout(() => window.dispatchEvent(new Event('resize')), 1000);
            navigator.mediaDevices.dispatchEvent(new CustomEvent('devicechange', {
                detail : {stream: _stream},
            }));
        });
        document.addEventListener('mixer-stream-oninactive', event => {
            const _stream = event.detail.stream;
            streamMixer.removeStream(_stream.stream);

            videoSelect.selectedIndex = 0;

            navigator.mediaDevices.dispatchEvent(new CustomEvent('devicechange', {
                detail : {selectedIndex : 0},
            }));
        });
    </script>

    <script data-script='stream'>
        let stream;
        document.addEventListener('croquetstartsession', event => {
            stream = AgoraRTC.createStream({
                streamID: view.viewId,

                audio: true,
                audioSource : streamMixer.audioStream.getAudioTracks()[0],

                video: true,
                videoSource: streamMixer.videoStream.getVideoTracks()[0],

                mirror: false,
            });

            stream.init(() => document.dispatchEvent(new CustomEvent('stream', {
                detail : {stream},
            })));
        });
    </script>

    <script data-script='localStreams'>
        const stopStream = (stream) => {
            if(stream)
                stream.getTracks().forEach(track => track.stop());
        };

        const localStreams = {
            video : null,
            audio : null,
        }
        document.addEventListener('croquetstartsession', event => {
            document.addEventListener('click', event => {
                navigator.mediaDevices.getUserMedia({video: true, audio: true})
                    .then(mediaStream => {
                        stopStream(mediaStream);

                        navigator.mediaDevices.dispatchEvent(new Event('devicechange'));

                        document.addEventListener('devicechange', event => {
                            videoSelect.dispatchEvent(new Event('input'));
                            audioSelect.dispatchEvent(new Event('input'));
                        }, {once: true});
                    });
            }, {once: true});
        });
    </script>

    <script data-script='channelName'>
        const url = new URL(window.location);
        const {searchParams} = url;
        let channelName = ' ';
        if(searchParams.has('channelName') && searchParams.get('channelName').length)
            channelName = searchParams.get('channelName');
    </script>

    <script data-script='appID'>
        const appID = '150d223019864b108fc38c6f37612e79';
    </script>

    <script data-script='client'>
        const client = AgoraRTC.createClient({mode: 'rtc', codec: 'vp8'});
        client.on('stream-added', event => client.subscribe(event.stream));
        client.on('stream-subscribed', event => {
            document.dispatchEvent(new CustomEvent('stream-subscribed', {
                detail : {stream : event.stream},
            }));
        });
        client.on('peer-leave', event => {
            document.dispatchEvent(new CustomEvent('peer-leave', {
                detail : {stream : event.stream},
            }));
        });

        client.on('mute-audio', event => {
            document.dispatchEvent(new CustomEvent('mute-audio', {
                detail : {id : event.uid}
            }));
        });
        client.on('unmute-audio', event => {
            document.dispatchEvent(new CustomEvent('unmute-audio', {
                detail : {id : event.uid}
            }));
        });

        client.on('mute-video', event => {
            document.dispatchEvent(new CustomEvent('mute-video', {
                detail : {id : event.uid}
            }));
        });
        client.on('unmute-video', event => {
            document.dispatchEvent(new CustomEvent('unmute-video', {
                detail : {id : event.uid}
            }));
        });

        document.addEventListener('stream', event => {
            client.init(appID, () => {
                client.join(null, channelName, view.viewId, viewId => {
                    document.dispatchEvent(new Event('join'));
                    client.publish(stream);
                });
            });
        }, {once: true});
    </script>

    <script data-script='mixerClient'>
        let mixerChannelName;
        const mixerClientStreams = [];

        const mixerClient = AgoraRTC.createClient({mode: 'rtc', codec: 'vp8'});
        mixerClient.on('stream-added', event => mixerClient.subscribe(event.stream));
        mixerClient.on('stream-subscribed', event => {
            mixerClientStreams.push(event.stream);

            event.stream.stream.oninactive = () => {
                const index = mixerClientStreams.indexOf(event.stream);
                delete mixerClientStreams[index];

                document.dispatchEvent(new CustomEvent('mixer-stream-oninactive', {
                    detail : {stream : event.stream},
                }));
            }

            document.dispatchEvent(new CustomEvent('mixer-stream-subscribed', {
                detail : {stream : event.stream},
            }));
        });

        mixerClient.on('peer-leave', event => {
            if(!MediaStream.prototype.hasOwnProperty('oninactive')) {
                const id = event.uid;
                const _stream = mixerClientStreams.find(_stream => _stream && _stream.getId() == id);
                if(_stream)
                    _stream.stream.oninactive();
            }

            document.dispatchEvent(new CustomEvent('mixer-peer-leave', {
                detail : {stream : event.stream},
            }));
        });

        document.addEventListener('croquetstartsession', event => {
            mixerChannelName = `${channelName}-${view.index}`;
            mixerClient.init(appID, () => {
                document.addEventListener('joinmixerclient', event => {
                    if(mixerClient.getConnectionState() == 'DISCONNECTED') {
                        mixerClient.join(null, mixerChannelName, view.viewId, viewId => {
                            document.dispatchEvent(new Event('mixerclientjoin'));
                        });
                    }
                });
                document.addEventListener('leavemixerclient', event => {
                    if(mixerClient.getConnectionState() == 'CONNECTED') {
                        mixerClient.leave(() => {
                            document.dispatchEvent(new Event('mixerclientleave'));
                        });
                    }
                });
            });
        });
    </script>

    <body>
        <style data-style='body'>
            body {
                margin: 0; padding: 0;
            }
        </style>

        <div id='cover'>
            <style data-style='cover'>
                #cover {
                    width: 100%; height: 100%;
                    position: absolute; z-index: 2;
                    
                    display: flex; flex-direction: column;
                    justify-content: center; text-align: center;

                    user-select: none;

                    background-color: white;

                }

                #coverText {
                    cursor: pointer;
                }

                #coverText[data-hidden] {
                    display: none;
                }
            </style>

            <h1 id='coverText' data-hidden>Click to Join</h1>

            <script data-script='cover'>
                const cover = document.querySelector('#cover');
                const coverText = document.querySelector('#coverText');
                document.addEventListener('croquetstartsession', event => {
                    coverText.removeAttribute('data-hidden');
                    document.addEventListener('click', event => {
                        cover.remove();
                    }, {once: true});
                });
            </script>
        </div>

        <div id='ui' data-hidden>
            <style data-style='ui'>
                #ui {
                    width: 100%; height: 100%;
                    display: flex;
                    align-items: stretch;
                    overflow: hidden;
                }

                #ui[data-hidden] {
                    display: none;
                }

                @media (min-aspect-ratio: 4/3) {
                    #ui {flex-direction: row-reverse}
                    #ui[data-resize], #ui[data-resizing] {cursor: ew-resize !important}
                }
                @media (max-aspect-ratio: 4/3) {
                    #ui {flex-direction: column}
                    #ui[data-resize], #ui[data-resizing] {cursor: ns-resize !important}
                }
            </style>

            <script data-script='ui'>
                const ui = document.querySelector('#ui');
                document.addEventListener('croquetstartsession', event => {
                    document.addEventListener('click', event => {
                        ui.removeAttribute('data-hidden');
                        window.dispatchEvent(new Event('resize'));
                    }, {once: true});
                });
            </script>

            <div id='profile'>
                <style data-style='profile'>
                    #profile {
                        /*background-color: lightgreen;*/
                        display: flex;
                        justify-content: start;
                        align-items: center;
                        align-content: center;   
                        flex-basis: 100px;
                        flex-grow: 0;
                        overflow: scroll;               
                    }

                    #profile::-webkit-scrollbar {
                        display: none;
                    }

                    #profile {
                        -ms-overflow-style: none;  /* IE and Edge */
                        scrollbar-width: none;  /* Firefox */
                    }

                    @media (min-aspect-ratio: 4/3) {#profile {
                        flex-direction: column;
                        border-left: solid black;
                    }}
                    @media (max-aspect-ratio: 4/3) {#profile {
                        flex-direction: row;
                        border-bottom: solid black;
                    }}

                    #muteAudio, #muteVideo, #toggleSettings {
                        user-select: none;
                        cursor: pointer;
                        display: block;
                        display: flex;
                        flex-direction: row;
                        justify-content: center;
                        align-items: center;

                        flex-grow: 0;
                        flex-shrink: 0;
                        border-radius: 50%;
                        width: 60px; height: 60px;
                        
                        /*background-color: green;*/
                        border: solid black;
                    }

                    #muteAudio span, #muteVideo span, #toggleSettings span {
                        text-align: center;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        cursor: pointer;
                        display: block;
                    }

                    @media (min-aspect-ratio: 4/3) {#muteAudio, #muteVideo, #toggleSettings {
                        margin-top: 20px;
                    }}
                    @media (max-aspect-ratio: 4/3) {#muteAudio, #muteVideo, #toggleSettings {
                        margin-left: 20px;
                    }}
                </style>

                <div id='output' class='mirror'>
                    <style data-style='output'>
                        #output {
                            display: flex;
                            position: relative;
                            cursor: pointer;
                            align-self: stretch;
                        }

                        #output canvas.video {
                            object-fit: contain;
                            align-self: stretch;
                        }

                        #output.mirror canvas.video {
                            transform: scaleX(-1);
                        }

                        @media (min-aspect-ratio: 4/3) {#output {

                        }}
                        @media (max-aspect-ratio: 4/3) {#output {
                            height: 100%;
                        }}

                        @media (min-aspect-ratio: 4/3) {#output canvas.video {
                            width: 100%;
                        }}
                        @media (max-aspect-ratio: 4/3) {#output canvas.video {
                            height: 100%;
                        }}
                    </style>

                    <canvas class='waveform'></canvas>
                    <canvas class='video' width='200' height='200' id='outputCanvas'></canvas>
                    <audio id='outputAudio' muted playsinline autoplay></audio>

                    <script data-script='output'>
                        const output = document.querySelector('#output');
                        output.addEventListener('click', event => {
                            cycleVideo.dispatchEvent(new Event('click'));
                        });
                        
                        const outputCanvas = document.querySelector('#outputCanvas');
                            streamMixer.addCanvas(outputCanvas);

                        const outputCanvasWaveform = output.querySelector('canvas.waveform');
                        const outputCanvasWaveformContext = outputCanvasWaveform.getContext('2d');

                        const outputAudio = document.querySelector('#outputAudio');
                            outputAudio.srcObject = streamMixer.audioStream.clone();
                            document.addEventListener('click', event => outputAudio.play(), {once: true});

                        document.addEventListener('croquetstartsession', event => {
                            document.addEventListener('mirror', event => {
                                const {mirror} = event.detail;
                                if(mirror)
                                    output.classList.add('mirror');
                                else
                                    output.classList.remove('mirror');
                            });
                        }, {once: true});
                    </script>
                </div>

                <style data-style='muteAudio'>
                    #muteAudio {
                        
                    }
                </style>
                <div id='muteAudio'>
                    <span>Mute</span>
                </div>
                <script data-script='muteAudio'>
                    const muteAudioButton = document.querySelector('#muteAudio');
                    document.addEventListener('stream', event => {
                        muteAudioButton.addEventListener('click', event => {
                            const muted = (event.detail && event.detail.muted !== undefined)?
                                event.detail.muted :
                                stream.isAudioOn();
                                                        
                            if(muted)
                                stream.muteAudio();
                            else
                                stream.unmuteAudio();
                            
                            if(event.isTrusted) {
                                if(!muted)
                                    testAudioButton.dispatchEvent(new CustomEvent('click', {
                                        detail : {muted : !muted},
                                    }));
                            }
                            
                            muteAudioButton.querySelector('span').innerText = muted?
                                'Unmute':
                                'Mute';
                            
                            if(muted)
                                document.dispatchEvent(new CustomEvent('mute-audio', {
                                    detail : {id : stream.getId()}
                                }));
                            else
                                document.dispatchEvent(new CustomEvent('unmute-audio', {
                                    detail : {id : stream.getId()}
                                }));
                            
                            if(muted)
                                streamMixer.canvasContext.filter = 'grayscale(100%)';
                            else
                                streamMixer.canvasContext.filter = 'none';
                            
                            if(muted)
                                output.classList.add('mute-audio');
                            else
                                output.classList.remove('mute-audio');

                        });

                        window.dispatchEvent(new Event('muteaudiobutton'));
                    }, {once: true});
                </script>

                <style data-style='muteVideo'>
                    #muteVideo {

                    }
                </style>
                <div id='muteVideo'>
                    <span>Hide</span>
                </div>
                <script data-script='muteVideo'>
                    const muteVideoButton = document.querySelector('#muteVideo');
                    document.addEventListener('stream', event => {
                        muteVideoButton.addEventListener('click', event => {
                            const muted = (event.detail && event.detail.muted !== undefined)?
                                event.detail.muted:
                                stream.isVideoOn();
                            
                            if(muted)
                                stream.muteVideo();
                            else
                                stream.unmuteVideo();
                            
                            if(event.isTrusted) {

                            }

                            muteVideoButton.querySelector('span').innerText = muted?
                                'Show':
                                'Hide';

                            if(muted)
                                document.dispatchEvent(new CustomEvent('mute-video', {
                                    detail : {id : stream.getId()}
                                }));
                            else
                                document.dispatchEvent(new CustomEvent('unmute-video', {
                                    detail : {id : stream.getId()}
                                }));
                            
                            if(muted)
                                output.classList.add('mute-video');
                            else
                                output.classList.remove('mute-video');
                        });

                        window.dispatchEvent(new Event('mutevideobutton'));
                    }, {once: true});
                </script>

                <style data-style='muteAudio'>
                    #toggleSettings {
                        
                    }         
                </style>
                <div id='toggleSettings'>
                    <span>Settings</span>
                </div>
                <script data-script='toggleSettings'>
                    const toggleSettingsButton = document.querySelector('#toggleSettings');
                    toggleSettingsButton.addEventListener('click', event => {
                        if(settings.hasAttribute('data-visible')) {
                            settings.removeAttribute('data-visible');
                            toggleSettingsButton.querySelector('span').innerText = 'Settings';
                        }
                        else {
                            settings.setAttribute('data-visible', '');
                            toggleSettingsButton.querySelector('span').innerText = 'Hide Settings';
                        }

                        const intervalId = window.setInterval(() => {
                            //window.dispatchEvent(new Event('resize'));
                        }, 10);

                        setTimeout(() => {
                            window.dispatchEvent(new Event('resize'));
                            window.clearInterval(intervalId);
                        }, 500);
                    });
                </script>
            </div>

            <div id='settings'>
                <style data-style='settings'>
                    #settings {
                        /*background-color: salmon;*/
                        transition: flex 0.5s;
                        overflow: scroll;
                        justify-content: start;

                        align-items: center;
                        
                        display: flex;
                        flex-shrink: 0;
                        flex-basis: 200px;
                        flex-grow: 0;
                    }

                    #settings::-webkit-scrollbar {
                        display: none;
                    }

                    #settings {
                        -ms-overflow-style: none;  /* IE and Edge */
                        scrollbar-width: none;  /* Firefox */
                    }

                    @media (min-aspect-ratio: 4/3) {#settings {
                        flex-direction: column;
                        border-left: solid black;
                    }}
                    @media (max-aspect-ratio: 4/3) {#settings {
                        flex-direction: row;
                        border-bottom: solid black;
                    }}

                    #settings:not([data-visible]) {
                        flex: 0;
                    }
                </style>

                <script data-script='settings'>
                    const settings = document.querySelector('#settings');
                </script>

                <div id='controls'>
                    <style data-style='controls'>
                        #controls {
                            display: none;
                            flex-direction: column;
                        }

                        #videoSelect, #audioSelect {
                            text-overflow: ellipsis;
                        }
                    </style>

                    <select id='videoSelect'></select>
                    <select id='audioSelect'></select>
                    <script data-script='select'>
                        const videoSelect = document.querySelector('#videoSelect');
                        
                        let videoSelectLock = false;
                        videoSelect.addEventListener('input', event => {
                            if(videoSelectLock) return;
                            videoSelectLock = true;

                            streamMixer.removeStream(localStreams.video);
                            stopStream(localStreams.video);

                            const option = videoSelect.options[videoSelect.selectedIndex];
                            if(option.hasAttribute('data-local')) {
                                navigator.mediaDevices.getUserMedia({video: {deviceId: {exact: videoSelect.value}}})
                                    .then(mediaStream => {
                                        localStreams.video = mediaStream;
                                        videoSelectLock = false;
                                        streamMixer.soloVideo(localStreams.video);
                                        document.dispatchEvent(new Event('localstreams'));

                                        const mirror = !videoSelect.options[videoSelect.selectedIndex].innerText.toLowerCase().includes('back')
                                        
                                        // delay?
                                        document.dispatchEvent(new CustomEvent('mirror', {
                                            detail : {mirror},
                                        }));
                                    });
                            }
                            else {
                                const _stream = mixerClientStreams.find(_stream => _stream && _stream.getId() == option.value);
                                if(_stream) {
                                    streamMixer.soloVideo(_stream.stream);
                                    // change aspect ratio?
                                    // FIX
                                }
                                videoSelectLock = false;

                                view.onUpdateMirror();
                            }
                        });

                        const audioSelect = document.querySelector('#audioSelect');
                        let audioSelectLock = false;
                        audioSelect.addEventListener('input', event => {
                            if(audioSelectLock) return;
                            audioSelectLock = true;
                            
                            streamMixer.removeStream(localStreams.audio);
                            stopStream(localStreams.audio);
                            
                            const option = audioSelect.options[audioSelect.selectedIndex];
                            if(option.hasAttribute('data-local')) {
                                navigator.mediaDevices.getUserMedia({audio: {deviceId: audioSelect.value}})
                                    .then(mediaStream => {
                                        localStreams.audio = mediaStream;
                                        audioSelectLock = false;
                                        document.dispatchEvent(new Event('localstreams'));
                                    });
                            }
                            else {
                                const _stream = mixerClientStreams.find(_stream => _stream && _stream.getId() == option.value);
                                if(_stream) {
                                    streamMixer.soloAudio(_stream.stream);
                                }
                                audioSelectLock = false;
                            }
                        });

                        let updatingSelects = false;
                        navigator.mediaDevices.addEventListener('devicechange', event => {
                            if(updatingSelects) return;
                            updatingSelects = true;
                            
                            videoSelect.innerHTML = '';
                            audioSelect.innerHTML = '';

                            navigator.mediaDevices.enumerateDevices().then(devices => devices.filter(device => device.kind.includes('input'))).then(outputDevices => {
                                outputDevices.forEach(device => {
                                    const {kind, deviceId, label} = device;
                                    
                                    const option = new Option(label, deviceId);
                                        option.setAttribute('data-local', '');
                                    
                                    const select = kind.includes('video')? videoSelect:audioSelect;
                                        select.appendChild(option);
                                });
                            }).then(() => {
                                mixerClientStreams.filter(stream => stream).forEach((_stream) => {
                                    const videoOption = new Option(_stream.getId(), _stream.getId());
                                    videoSelect.appendChild(videoOption);
                                    
                                    //const audioOption = new Option(_stream.getId(), _stream.getId());
                                    //audioSelect.appendChild(audioOption);
                                    
                                    if(event.detail && event.detail.stream && event.detail.stream == _stream) {
                                        videoSelect.selectedIndex = Array.from(videoSelect.options).indexOf(videoOption);
                                        view.onUpdateMirror();

                                        //audioSelect.selectedIndex = Array.from(audioSelect.options).indexOf(audioOption);
                                    }
                                });

                                if(event.detail && !isNaN(event.detail.selectedIndex)) {
                                    videoSelect.selectedIndex = event.detail.selectedIndex;
                                    videoSelect.dispatchEvent(new Event('input'));
                                    view.onUpdateMirror();
                                }

                                updatingSelects = false;

                                document.dispatchEvent(new Event('devicechange'));
                            });
                        });
                    </script>
                </div>

                <div id='settingsButtons'>
                    <style data-style='settingsButtons'>

                        #settingsButtons {
                            display: flex;
                            flex-direction: column;
                            align-self: stretch;
                        }

                        @media (min-aspect-ratio: 4/3) {#settingsButtons {
                            
                        }}
                        @media (max-aspect-ratio: 4/3) {#settingsButtons {
                            
                        }}
                        
                        #settingsButtons > div {
                            user-select: none;
                            cursor: pointer;

                            /*width: 80px; height: 80px;*/
                            
                            border: solid black;
                            /*background-color: red;*/

                            display: flex;
                            justify-content: center;
                            flex-grow: 0;
                            flex-shrink: 0;
                            flex: 1;
                        }

                        #cycleVideo {
                            display: none !important;
                        }

                        #settingsButtons > div > span {
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                            text-align: center;
                            
                        }
                    </style>

                    <div id='cycleVideo'>
                        <span>Cycle Video</span>
                    </div>
                    <div id='cycleAudio'>
                        <span>Cycle Audio</span>
                    </div>
                    <script data-script='cycleSelect'>
                        const cycleVideo = document.querySelector('#cycleVideo');
                        cycleVideo.addEventListener('click', event => {
                            if(videoSelect.childElementCount > 1) {
                                videoSelect.selectedIndex = (videoSelect.selectedIndex+1) % videoSelect.childElementCount;
                                videoSelect.dispatchEvent(new Event('input'));
                            }
                        });

                        const cycleAudio = document.querySelector('#cycleAudio');
                        cycleAudio.addEventListener('click', event => {
                            if(audioSelect.childElementCount > 1) {
                                audioSelect.selectedIndex = (audioSelect.selectedIndex+1) % audioSelect.childElementCount;
                                audioSelect.dispatchEvent(new Event('input'));
                            }
                        });
                    </script>

                    <div id='testAudio'>
                        <span>Test Audio</span>

                        <script data-script='testAudio'>
                            const testAudioButton = document.querySelector('#testAudio');
                            testAudioButton.addEventListener('click', event => {
                                const muted = (event.detail.muted !== undefined)?
                                    event.detail.muted :
                                    !outputAudio.muted;
                                
                                outputAudio.muted = muted;
                                
                                if(event.isTrusted) {
                                    if(true || !muted)
                                        muteAudioButton.dispatchEvent(new CustomEvent('click', {
                                            detail : {muted : !muted}
                                        }));
                                }

                                testAudioButton.querySelector('span').innerText = outputAudio.muted?
                                    'Test Audio':
                                    'Stop Testing Audio';    
                            });
                        </script>
                    </div>

                    <div id='presentationMode'>
                        <span>Present</span>

                        <script data-script='presentationMode'>
                            const presentationModeButton = document.querySelector('#presentationMode');
                            document.addEventListener('croquetstartsession', event => {
                                presentationModeButton.addEventListener('click', event => {
                                    view.togglePresentationMode(!ui.classList.contains('presentation'));
                                });

                                document.addEventListener('presentationmode', event => {
                                    if(view.model.presentationMode) {
                                        ui.classList.add('presentation');
                                        presentationModeButton.querySelector('span').innerText = 'Show Peers';
                                    }
                                    else {
                                        ui.classList.remove('presentation');
                                        presentationModeButton.querySelector('span').innerText = 'Present';
                                    }

                                    setTimeout(() => window.dispatchEvent(new Event('resize')), 500);

                                    /*
                                    const intervalId = window.setInterval(() => {
                                        //window.dispatchEvent(new Event('resize'));
                                    }, 10);

                                    setTimeout(() => {
                                        window.dispatchEvent(new Event('resize'));
                                        window.clearInterval(intervalId);
                                    }, 500);
                                    */
                                });

                                document.dispatchEvent(new Event('presentationmode'));
                            }, {once: true});
                        </script>
                    </div>


                    <div id='shareScreen'>
                        <span>Share Screen</span>

                        <style data-style='shareScreen'>
                            #shareScreen {
                                display: none !important;
                            }
                        </style>

                        <script data-script='shareScreen'>
                            const shareScreenButton = document.querySelector('#shareScreen');

                            // https://docs.agora.io/en/Interactive%20Broadcast/screensharing_web?platform=Web
                            const shareScreenClient = AgoraRTC.createClient({mode: 'rtc', codec: 'vp8'});
                            const shareScreenStream = AgoraRTC.createStream({
                                screen: true, screenAudio: true,
                                video: true, audio: true,
                            });

                            document.addEventListener('croquetstartsession', event => {
                                shareScreenClient.init(appID, () => {
                                    shareScreenButton.addEventListener('click', event => {
                                        switch(shareScreenClient.getConnectionState()) {
                                            case 'DISCONNECTED':
                                                shareScreenStream.init(() => {
                                                    shareScreenClient.join(null, channelName, `${view.viewId}-screen`, viewId => {
                                                        shareScreenClient.publish(shareScreenStream);
                                                        shareScreenButton.innerText = 'Stop Screen Screen';
                                                    });
                                                });
                                                break;

                                            case 'CONNECTED':
                                                shareScreenClient.unpublish(shareScreenStream);
                                                shareScreenStream.close();
                                                shareScreenClient.leave(() => {
                                                    shareScreenButton.innerText = 'Share Screen';
                                                });
                                                break;
                                            default:
                                                break;
                                        }
                                    });
                                });
                            }, {once: true});
                        </script>
                    </div>
                </div>

                <a id='qrcode'>
                    <style data-style='qrcode'>
                        #qrcode {
                            align-self: center;
                            width: 200px; height: 200px;
                            background-color: white;
                            flex-shrink: 0;
                            
                        }


                        #qrcode img, #qrcode canvas {
                            width: 100%;
                            height: 100%;
                            object-fit: contain;
                            border: solid white 10px;
                            box-sizing: border-box;
                        }
                    </style>

                    <script data-script='qrcode'>
                        const qrcode = document.querySelector('#qrcode');

                        document.addEventListener('croquetstartsession', event => {
                            const qrcodeURL = `https://${location.host}/c?c=${channelName}&i=${view.index}`;
                            new QRCode(qrcode, {
                                text: qrcodeURL,
                                width: 250,
                                height: 250,
                                colorDark : "#000000",
                                colorLight : "#ffffff",
                                correctLevel : QRCode.CorrectLevel.H,
                            });
                            qrcode.href = qrcodeURL;
                            qrcode.title = '';
                        }, {once: true});
                    </script>
                </a>

                <div id='volume'>
                    <style data-style='volume'>
                        #volume {
                            display: flex;
                            flex-direction: column;
                            align-self: center;
                        }

                        @media (min-aspect-ratio: 4/3) {#volume {
                            width: 90%;
                            margin-top: 20px;
                        }}
                        @media (max-aspect-ratio: 4/3) {#volume {
                            height: 90%;
                        }}

                        #volumeInput {
                            flex: 1;
                            align-self: center;
                            cursor: pointer;
                        }

                        #volumeTitle {
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                        }
                        #volumeTitle span {
                            text-align: center;
                        }
                    </style>

                    <div id='volumeTitle'>
                        <span>Volume</span>
                    </div>

                    <input id='volumeInput' type='range' value='1' min='0' max='2' step='0.01'>
                    <style data-style='volumeInput'>
                        @media (min-aspect-ratio: 4/3) {#volumeInput {
                            width: 100%;
                        }}
                        @media (max-aspect-ratio: 4/3) {#volumeInput {
                            -webkit-appearance: slider-vertical;
                            writing-mode: bt-lr;
                            height: 80%;
                        }}
                    </style>

                    <script data-script='volume'>
                        const volumeInput = document.querySelector('#volumeInput');
                        volumeInput.addEventListener('input', event => {
                            const gain = Number(event.target.value);
                            streamMixer.audioInputs.forEach(audioInput => audioInput.gain = gain);
                        });
                    </script>
                </div>
            </div>

            <div id='activePeer'>
                <style data-style='activePeer'>
                    #activePeer {
                        /*background-color: powderblue;*/
                        display: flex;
                        align-content: center;
                        justify-content: center;
                        flex-shrink: 0;
                        flex-grow: 0;
                        flex: 1;
                        transition: flex 0.5s;
                    }

                    #activePeer.pointer {
                        cursor: pointer;
                    }

                    @media (min-aspect-ratio: 4/3) {#activePeer {
                        flex-direction: column;
                    }}
                    @media (max-aspect-ratio: 4/3) {#activePeer {
                        flex-direction: row;
                    }}

                    #ui[data-resizing] #activePeer {
                        transition: none;
                    }

                    .presentation #activePeer {
                        
                    }

                    #activePeerOutput {
                        align-self: stretch;
                        position: relative;
                        height: 100%;
                        width: 100%;
                    }

                    #activePeerOutput canvas.video, #activePeerOutput video {
                        flex: 1;
                        width: 100%;
                        height: 100%;
                    }

                    @media (min-aspect-ratio: 4/3) {#activePeerOutput {
                        flex-direction: row; height: 100%;
                        border-left: solid black;
                    }}
                    @media (max-aspect-ratio: 4/3) {#activePeerOutput {
                        flex-direction: column; width: 100%;
                        border-bottom: solid black;
                    }}

                    #activePeer.mute-video #activePeerOutput {
                        background-color: hsl(0, 0%, 10%);
                    }

                    #activePeer.mute-video #activePeerOutput > div {
                        background-color: transparent !important;
                    }

                    #activePeer.mirror canvas.video, #activePeer.mirror video {
                        transform: scaleX(-1);
                    }

                    .presentation #activePeer video {
                        transform: scaleX(-1);
                    }

                    #activePeer:not([data-canvas]) canvas.video {
                        display: none;
                    }
                    #activePeer[data-canvas] video {
                        display: none;
                    }

                    #activePeer canvas.video, #activePeer video {
                        object-fit: contain;
                    }

                    @media (max-aspect-ratio: 4/3) {#activePeer canvas.video, #activePeer video {
                        /*object-fit: cover;*/
                    }}

                    #activePeer.mute-video canvas.video, #activePeer.mute-video video {
                        opacity: 0;
                    }
                </style>

                <div id='activePeerOutput'>
                    <canvas class='waveform'></canvas>
                    <video muted playsinline autoplay></video>
                    <canvas class='video'></canvas>
                </div>
            </div>

            <script data-script='activePeer'>
                const activePeer = document.querySelector('#activePeer');
                const activePeerWaveformCanvas = activePeer.querySelector('canvas.waveform');
                const activePeerWaveformCanvasContext = activePeerWaveformCanvas.getContext('2d');

                const activePeerVideo = activePeer.querySelector('video');
                const activePeerVideoCanvas = activePeer.querySelector('canvas.video');

                document.addEventListener('mirror', event => {
                    if(activePeer.dataset.id == stream.getId()) {
                        const {mirror} = event.detail;
                        if(mirror)
                            activePeer.classList.add('mirror');
                        else
                            activePeer.classList.remove('mirror');
                    }
                });

                activePeer.addEventListener('click', event => {
                    if(ui.hasAttribute('data-resize' || ui.hasAttribute('data-resizing'))) return;

                    if(activePeer.dataset.id == stream.getId())
                        cycleVideo.dispatchEvent(new Event('click'));
                });

                let activePeerLock = false;
                document.addEventListener('activepeer', event => {
                    if(activePeerLock) return;
                    activePeerLock = true;
                    
                    const _stream = event.detail.stream;
                    const id = _stream.getId();
                    const peer = getPeer(id);

                    if(peer) {
                        if(peer.classList.contains('mute-video'))
                            activePeer.classList.add('mute-video')
                        else
                            activePeer.classList.remove('mute-video');

                        if(peer.classList.contains('mirror'))
                            activePeer.classList.add('mirror');
                        else
                            activePeer.classList.remove('mirror');
                        
                        if(peer.classList.contains('mute-audio'))
                            activePeer.classList.add('mute-audio');
                        else
                            activePeer.classList.remove('mute-audio');
                                                
                        if(id != activePeer.dataset.id) {
                            if(stream == _stream) {
                                streamMixer.addCanvas(activePeerVideoCanvas);
                                activePeer.dataset.canvas =  '';
                                activePeerVideo.srcObject = null;
                            }
                            else {
                                streamMixer.removeCanvas(activePeerVideoCanvas);
                                activePeerVideo.srcObject = _stream.stream;
                                delete activePeer.dataset.canvas;
                            }
                        }

                        //activePeer.style.display = 'inherit';
                        if(stream == _stream)
                            activePeer.classList.add('pointer');
                        else
                            activePeer.classList.remove('pointer');

                        activePeer.dataset.id = id;
    
                        window.dispatchEvent(new Event('resize'));
                    }

                    activePeerLock = false;
                });

                window.addEventListener('resize', event => {
                    const containerAspectRatio = activePeer.clientWidth/activePeer.clientHeight;
                    let videoContainer, videoAspectRatio;

                    if(!activePeer.hasAttribute('data-id')) return;
                    
                    if(stream.getId() == activePeer.dataset.id) {
                        videoContainer = activePeerVideoCanvas;
                        videoAspectRatio = videoContainer.width/videoContainer.height;
                    }
                    else {
                        videoContainer = activePeerVideo;
                        const {width, height} = videoContainer.srcObject.getVideoTracks()[0].getSettings();
                        videoAspectRatio = width/height;
                    }

                    if(!isNaN(videoAspectRatio) && !isNaN(containerAspectRatio)) {
                        videoContainer.style.objectFit = (videoAspectRatio < containerAspectRatio)?
                            'contain':
                            'cover';
                    }
                });
            </script>

            <div id='peers'>
                <style data-style='peers'>
                    #peers {
                        background-color: black;
                        flex-basis: 40%;
                        flex-grow: 0;

                        width: 100%; height: 100%;
                        

                        display: grid;
                        grid-template-columns: 100%;
                        grid-template-rows: 100%;

                        justify-content: center; align-items: center;
                        grid-auto-flow: dense;

                        overflow: hidden;

                        transition: flex 0.5s;
                    }

                    #ui[data-resizing] #peers {
                        transition: none;
                    }

                    .presentation #peers {
                        flex: 0 !important;
                    }
                </style>

                <style data-style='peer'>
                    .peer {
                        position: relative;
                        width: 100%; height: 100%;
                        /*background-color: black;*/
                        border: solid black thin;
                        box-sizing: border-box
                    }

                    #ui:not([data-resizing]):not([data-resize]) .peer.pointer {
                        cursor: pointer;
                    }

                    .peer.mute-video {
                        background-color: hsl(0, 0%, 10%);
                    }

                    .peer.mute-video > div {
                        background-color: transparent !important;
                    }

                    .peer canvas.video, .peer video {
                        width: 100%;
                        height: 100%;
                        object-fit: contain;
                    }

                    @media (max-aspect-ratio: 4/3) {.peer canvas.video, .peer video {
                        /*object-fit: cover !important;*/
                    }}

                    .peer.mirror canvas.video, .peer.mirror video {
                        transform: scaleX(-1);
                    }
                    
                    .mute-audio video, .mute-audio canvas.video {
                        filter: grayscale(100%);
                    }

                    .mute-audio {
                        filter: grayscale(100%);
                    }

                    .peer.mute-video canvas.video, .peer.mute-video video {
                        display: none;
                        /* DEBUG */
                    }

                    canvas.waveform {
                        position: absolute; z-index: 2;
                        width: 100%;
                        height: 20%;
                        bottom: 0;
                        -webkit-mask-image: linear-gradient(to right, transparent, black, transparent);
                        mask-image: linear-gradient(to right, transparent, black, transparent);
                    }
                </style>

                <template>
                    <div class='peer'>
                        <canvas class='waveform'></canvas>
                    </div>
                </template>

                <script data-script='peers'>
                    const streams = [];

                    document.addEventListener('stream', event => {
                        document.dispatchEvent(new CustomEvent('addpeer', {
                            detail : {stream : event.detail.stream},
                        }));
                    }, {once: true});

                    document.addEventListener('stream-subscribed', event => {
                        document.dispatchEvent(new CustomEvent('addpeer', {
                            detail : {stream : event.detail.stream},
                        }));
                    });

                    const peers = document.querySelector('#peers');
                    const peerTemplate = peers.querySelector('template');
                    
                    document.addEventListener('addpeer', event => {
                        const _stream = event.detail.stream;
                        streams.push(_stream);

                        /*
                        if(streams.length == 3 && view.model.presentationMode == true)
                            view.togglePresentationMode(false);
                        */

                        document.addEventListener('click', event => {
                            _stream.getAudioLevel();
                            _stream.audioLevelHelper.audioContext.resume();
                        }, {once: true});

                        _stream.getAudioLevel();

                        const peer = peerTemplate.content.cloneNode(true).querySelector('.peer');

                        if(_stream == stream)
                            peer.classList.add('mirror');
                        
                        if(_stream == stream) {
                            peer.addEventListener('click', event => {
                                if(ui.hasAttribute('data-resize' || ui.hasAttribute('data-resizing'))) return;

                                cycleVideo.dispatchEvent(new Event('click'));
                            });
                            peer.classList.add('pointer');
                        }

                        if(!_stream.isAudioOn())
                            peer.classList.add('mute-audio');
                            
                        if(!_stream.isVideoOn())
                            peer.classList.add('mute-video');

                        const id = _stream.getId();
                        peer.dataset.id = id;
                        const viewId = id.split('-')[0];
                        let order = view.model.getIndex(viewId)*2;
                        if(id.includes('screen')) {
                            order++;
                            peer.style.objectFit = 'contain';
                        }
                        peer.style.order = order;
                        peer.id = `peer-${id}`;

                        peers.appendChild(peer);
                        _stream.stream.oninactive = () => {
                            peer.remove();
                            streams.splice(streams.indexOf(_stream, 1));
                        
                            document.dispatchEvent(new CustomEvent('removepeer', {
                                detail : {stream : _stream},
                            }));
                        }

                        if(_stream == stream) {
                            peer.appendChild(streamMixer.canvas);
                        }
                        else {
                            _stream.play(peer.id, {fit: 'contain'});
                            const video = peer.querySelector('video');
                            document.addEventListener('click', event => {
                                const audio = peer.querySelector('audio');
                                if(audio) {
                                    audio.muted = false;
                                    audio.play();
                                }
                            }, {once: true});
                        }

                        window.dispatchEvent(new Event('resize'));
                    });

                    document.addEventListener('mute-audio', event => {
                        const id = event.detail.id;
                        const peer = getPeer(id);

                        if(peer) {
                            peer.classList.add('mute-audio');

                            if(activePeer.dataset.id == id) {
                                activePeer.classList.add('mute-audio');
                            }
                        }
                    });
                    document.addEventListener('unmute-audio', event => {
                        const id = event.detail.id;
                        const peer = getPeer(id);

                        if(peer) {
                            peer.classList.remove('mute-audio');

                            if(activePeer.dataset.id == id) {
                                activePeer.classList.remove('mute-audio');
                            }
                        }
                    });

                    document.addEventListener('mute-video', event => {
                        const id = event.detail.id;
                        const peer = getPeer(id);

                        if(peer) {
                            peer.classList.add('mute-video');

                            if(activePeer.dataset.id == id) {
                                activePeer.classList.add('mute-video');
                            }
                        }
                    });

                    document.addEventListener('unmute-video', event => {
                        const id = event.detail.id;
                        const peer = getPeer(id);

                        if(peer) {
                            peer.classList.remove('mute-video');

                            if(activePeer.dataset.id == id) {
                                activePeer.classList.remove('mute-video');
                            }
                        }
                    });
                    
                    const getPeer = (id) => {
                        return peers.querySelector(`[data-id="${id}"]`);
                    }

                    document.addEventListener('mirror', event => {
                        const peer = getPeer(stream.getId());

                        const {mirror} = event.detail;
                        if(mirror)
                            peer.classList.add('mirror');
                        else
                            peer.classList.remove('mirror');
                    });

                    document.addEventListener('croquetstartsession', event => {
                        window.addEventListener('resize', event => {
                            if(ui.classList.contains('presentation')) return;

                            const width = peers.clientWidth;
                            const height = peers.clientHeight;
    
                            const aspectRatio = width/height;
    
                            let rows = 1;
                            let columns = 1;
    
                            let gridTemplateColumns = ``;
                            let gridTemplateRows = ``;
                            
                            const _peers = peers.querySelectorAll('.peer:not(template)');
                            let numberOfPeers = _peers.length;
                            numberOfPeers = Math.max(1, numberOfPeers);
    
                            while(numberOfPeers > rows*columns) {
                                const aspectRatios = {
                                    row : Math.abs(aspectRatio - columns/(rows+1)),
                                    column : Math.abs(aspectRatio - (columns+1)/rows),
                                };
    
                                if(aspectRatios.row < aspectRatios.column)
                                    rows++
                                else
                                    columns++;
                            }
    
                            gridTemplateColumns = `repeat(${columns}, 1fr)`;
                            gridTemplateRows = `repeat(${rows}, 1fr)`;
                            
                            let length = Math.floor(Math.min(width/columns, height/rows));
                            const canvasLength = Math.sqrt((1280*720)/numberOfPeers);
                            length = Math.min(length, canvasLength);
                            length = Math.max(length, 32);
                            if(streamMixer) {
                                streamMixer.height = canvasLength;

                                document.querySelectorAll('canvas.waveform').forEach(canvas => {
                                    canvas.width = length;
                                    canvas.height = length*0.2;
                                });
                            }

                            const lengthString = `${length}px`;
    
                            //gridTemplateColumns = gridTemplateColumns.replace(/1fr/g, lengthString);
                            //gridTemplateRows = gridTemplateRows.replace(/1fr/g, lengthString);
                            
                            peers.style.gridTemplateRows = gridTemplateRows;
                            peers.style.gridTemplateColumns = gridTemplateColumns;

                            _peers.forEach(peer => {
                                const containerAspectRatio = peer.clientWidth/peer.clientHeight;
                                let videoContainer, videoAspectRatio;
                                
                                if(peer.dataset.id == stream.getId()) {
                                    videoContainer = peer.querySelector('canvas.video');
                                    videoAspectRatio = videoContainer.width/videoContainer.height;
                                }
                                else {
                                    videoContainer = peer.querySelector('video');
                                    const {width, height} = videoContainer.srcObject.getVideoTracks()[0].getSettings();
                                    videoAspectRatio = width/height;
                                }
                                
                                if(!isNaN(containerAspectRatio) && !isNaN(videoAspectRatio)) {
                                    videoContainer.style.objectFit = (videoAspectRatio < containerAspectRatio)?
                                        'contain':
                                        'cover';
                                }
                            });
                        });

                        window.dispatchEvent(new Event('resize'));
                        document.addEventListener('removepeer', event => {
                            window.dispatchEvent(new Event('resize'));
                        });
                    });
                    
                    let resizingPeers = false;
                    document.addEventListener('mousemove', event => {
                        if(ui.classList.contains('presentation')) return;

                        const {flexDirection} = getComputedStyle(ui);
                        if(flexDirection.includes('row')) {
                            if(Math.abs(event.clientX - peers.offsetWidth) < 20)
                                ui.setAttribute('data-resize', '');
                            else
                                ui.removeAttribute('data-resize');
                        }
                        else {
                            if(Math.abs(event.clientY - peers.offsetTop) < 20)
                                ui.setAttribute('data-resize', '');
                            else
                                ui.removeAttribute('data-resize');
                        }
                    });

                    document.addEventListener('mousedown', event => {
                        if(ui.classList.contains('presentation')) return;

                        const {flexDirection} = getComputedStyle(ui);
                        if(flexDirection.includes('row'))
                            resizingPeers = (Math.abs(event.clientX - peers.offsetWidth) < 20);
                        else
                            resizingPeers = (Math.abs(event.clientY - peers.offsetTop) < 20);
                        
                        if(resizingPeers)
                            ui.setAttribute('data-resizing', '');
                        else
                            ui.removeAttribute('data-resizing');
                    });
                    document.addEventListener('mousemove', event => {
                        if(ui.classList.contains('presentation')) return;

                        if(resizingPeers) {
                            const {flexDirection} = getComputedStyle(ui);

                            if(flexDirection.includes('row')) {
                                const width = peers.clientWidth + event.movementX;
                                peers.style.flexBasis = `${100*event.clientX/ui.clientWidth}%`;
                            }
                            else {
                                const height = peers.clientHeight - event.movementY;
                                peers.style.flexBasis = `${100*(ui.clientHeight-event.clientY)/ui.clientHeight}%`;
                            }
                            
                            window.dispatchEvent(new Event('resize'));
                        }
                    });
                    document.addEventListener('mouseup', event => {
                        resizingPeers = false;
                        ui.removeAttribute('data-resizing');
                        event.preventDefault();
                    });

                    const waveforms = {};
                    const period = 0.2;
                    const numberOfWaveformSamples = 100;

                    document.addEventListener('stream', event => {
                        window.setInterval(() => {
                            streams.forEach(_stream => {
                                let waveform = waveforms[_stream.getId()];
                                if(!waveform) {
                                    waveform = waveforms[_stream.getId()] = new Array(0);
                                    waveform.fill(0);
                                }

                                const audioLevel = _stream.getAudioLevel();

                                waveform.push(audioLevel);
                                if(waveform.length > numberOfWaveformSamples)
                                    waveform.shift();
                            });
                        }, 1000*period/numberOfWaveformSamples);

                        window.setInterval(() => {
                            const levels = streams.map(_stream => _stream.getAudioLevel());
                            let maxIndex = 0;
                            let maxLevel = 0;
                            levels.forEach((level, index) => {
                                if(level > maxLevel) {
                                    maxLevel = level;
                                    maxIndex = index;
                                }
                            });

                            if(maxLevel > 0.32)
                                document.dispatchEvent(new CustomEvent('activepeer', {
                                    detail : {
                                        stream : streams[maxIndex],
                                    }
                                }));
                        }, 200);

                        const waveformAnimationLoop = () => {
                            streams.forEach(_stream => {
                                const id = _stream.getId();

                                const peer = getPeer(id);
                                const waveform = waveforms[id];

                                if(peer && waveform) {
                                    const canvas = peer.querySelector('canvas.waveform');
                                    const context = canvas.getContext('2d');
    
                                    const sampleWidth = canvas.width/numberOfWaveformSamples;
                                    context.clearRect(0, 0, canvas.width, canvas.height);
    
                                    context.fillStyle = 'green';
                                    waveform.forEach((sample, index) => {
                                        sample = Math.max(0.07, sample);
                                        const sampleHeight = sample * canvas.height;
    
                                        const sampleX = (index*sampleWidth);
                                        const sampleY = canvas.height*(0.5 - (sample/2));
            
                                        context.fillRect(sampleX, sampleY, sampleWidth, sampleHeight);
                                    });
    
                                    if(stream == _stream) {
                                        outputCanvasWaveformContext.clearRect(0, 0, outputCanvasWaveform.width, outputCanvasWaveform.height);
                                        outputCanvasWaveformContext.drawImage(canvas, 0, 0);
                                    }
    
                                    if(_stream.getId() == activePeer.dataset.id) {
                                        activePeerWaveformCanvasContext.clearRect(0, 0, activePeerWaveformCanvas.width, activePeerWaveformCanvas.height);
                                        activePeerWaveformCanvasContext.drawImage(canvas, 0, 0);
                                    }
                                }
                            });
                            window.requestAnimationFrame(waveformAnimationLoop);
                        }
                        window.requestAnimationFrame(waveformAnimationLoop);
                    }, {once: true});
                </script>
            </div>
        </div>
    </body>

    <script data-script='croquet'>
        class Model extends Croquet.Model {
            init() {
                super.init();

                this.users = [];

                this.presentationMode = false;

                this.subscribe(this.sessionId, 'peer-join', this.onPeerJoin);
                this.subscribe(this.sessionId, 'peer-leave', this.onPeerLeave);

                this.subscribe(this.sessionId, 'camera-join', this.onCameraJoin);

                this.subscribe(this.sessionId, 'camera-mirror', this.onCameraMirror);

                this.subscribe(this.sessionId, 'set-presentation-mode', this.setPresentationMode);
            }

            setPresentationMode({presentationMode}) {
                this.presentationMode = presentationMode;
                this.publish(this.sessionId, 'on-presentation-mode');
            }

            cleanupUsers() {
                if(this.users.every(user => user == undefined))
                    this.users.length = 0;
            }

            onPeerJoin(viewId) {
                this.cleanupUsers();

                if(this.users.every(user => user.viewId !== viewId)) {
                    this.users.push({
                        viewId,
                        cameras : [],
                    });
    
                    this.publish(this.sessionId, 'on-peer-join', viewId);
                }
            }
            onPeerLeave(viewId) {
                const user = this.getUser(viewId);
                
                if(user) {
                    delete this.users[this.users.indexOf(user)];
                    this.publish(this.sessionId, 'on-peer-exit', viewId);
                }
                else {
                    const camera = this.getCamera(viewId);
                    if(camera) {
                        const cameraUser = this.users.find(user => user && user.cameras.includes(camera));
                        if(cameraUser) {
                            const cameraIndex = cameraUser.cameras.indexOf(camera);
                            delete cameraUser.cameras[cameraIndex];
                            if(cameraUser.cameras.every(camera => camera == undefined))
                                cameraUser.cameras.length = 0;
                            this.publish(cameraUser.viewId, 'on-camera-exit', viewId);
                        }
                    }
                }
            }

            onCameraJoin({cameraViewId, userViewId}) {                
                const user = this.getUser(userViewId);

                if(user) {
                    if(!user.cameras.find(camera => camera && camera.viewId == cameraViewId))
                        user.cameras.push({
                            viewId : cameraViewId,
                            mirror : true,
                        });
                        
                    this.publish(userViewId, 'on-camera-join', cameraViewId);
                }
            }
            
            onCameraMirror({cameraViewId, userViewId, mirror}) {
                const camera = this.getCamera(cameraViewId);
                if(camera) {
                    camera.mirror = mirror;
                    this.publish(userViewId, 'on-camera-mirror', cameraViewId);
                }
            }

            getIndex(viewId) {
                return this.users.findIndex(user => user !== undefined && user.viewId == viewId);
            }
            getUser(viewId) {
                return this.users[this.getIndex(viewId)];
            }

            getCamera(viewId) {
                let camera;
                const user = this.users.some(user => {
                    if(user) {
                        camera = user.cameras.find(camera => camera !== undefined && camera.viewId == viewId);
                        return camera;
                    }
                });
                return camera;
            }
        }
        Model.register();

        class UserView extends Croquet.View {
            constructor(model) {
                super(model);
                this.model = model;

                this.subscribe(this.sessionId, 'on-peer-join', viewId => {
                    if(viewId == this.viewId)
                        document.dispatchEvent(new Event('croquetstartsession'));
                });

                this.subscribe(this.viewId, 'on-camera-join', viewId => {
                    if(this.user.cameras.length > 0) {
                        document.dispatchEvent(new Event('joinmixerclient'));
                    }
                });

                this.subscribe(this.viewId, 'on-camera-exit', viewId => {
                    if(this.user.cameras.length == 0) {
                        document.dispatchEvent(new Event('leavemixerclient'));
                    }
                });

                this.subscribe(this.viewId, 'on-camera-mirror', this.onUpdateMirror);

                this.subscribe(this.sessionId, 'on-presentation-mode', () => {
                    document.dispatchEvent(new Event('presentationmode'));
                });

                this.join();

                view = this;
            }

            onUpdateMirror() {
                const camera = this.model.getCamera(videoSelect.value);
                if(camera) {
                    document.dispatchEvent(new CustomEvent('mirror', {
                        detail : {mirror : camera.mirror},
                    }));
                }
            }

            join() {
                this.publish(this.sessionId, 'peer-join', this.viewId);
            }

            get index() {
                return this.model.getIndex(this.viewId);
            }

            get user() {
                return this.model.getUser(this.viewId);
            }

            togglePresentationMode(presentationMode) {
                this.publish(this.sessionId, 'set-presentation-mode', {
                    presentationMode,
                });
            }

            leave() {
                this.publish(this.sessionId, 'peer-leave', this.viewId);
            }
        }

        let view;
        Croquet.App.root = false;
        window.addEventListener('startSession', event => {
            Croquet.startSession(`q-chat-${channelName}`, Model, UserView)
                .then(session => {
                    view = session.view;
    
                    window.addEventListener('unload', event => {
                        view.leave();
                    });
                });
        }, {once: true});
    </script>

    <script data-script='boardwalk'>
        if(window.parent == window) {
            window.dispatchEvent(new Event('startSession'));
        }
        else {
            window.addEventListener('message', event => {
                const {message} = event.data;
                if(message == 'landingPage') {
                    const {href} = event.data;
                    channelName = (new URL(href)).hash.replace('#', '');
                    window.dispatchEvent(new Event('startSession'));

                    const {mic, video} = event.data.data;
                    console.log(mic, video);
                    window.addEventListener('muteaudiobutton', event => {
                        if(mic == 'off')
                            muteAudioButton.dispatchEvent(new CustomEvent('click', {
                                detail : {muted : true},
                            }));
                    }, {once: true});

                    window.addEventListener('mutevideobutton', event => {
                        if(video == 'off')
                            muteVideoButton.dispatchEvent(new CustomEvent('click', {
                                detail : {muted : true},
                            }));
                    }, {once: true});
                }
            });
            window.parent.postMessage('askLandingPageInfo', '*');

            /*
            const timeoutId = window.setTimeout(() => {
                window.dispatchEvent(new Event('startSession'));
            }, 500);
            */
        }
    </script>
</html>