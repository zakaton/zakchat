<html>
    <head>
        <title>Croquet Video Chat</title>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>

        <!-- https://docs.agora.io/en/Video/start_call_web?platform=Web -->
        <script src='https://cdn.agora.io/sdk/release/AgoraRTCSDK-3.1.0.js'></script>

        <!-- https://github.com/davidshimjs/qrcodejs -->
        <script src='https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js'></script>

        <meta charset="utf-8">
        <script src="https://croquet.io/sdk/croquet-latest.min.js"></script>
    </head>

    <script data-script='https'>
        if(location.protocol !== 'https:')
            location.replace(`https:${location.href.substring(location.protocol.length)}`)
    </script>

    <script data-script='logger'>
        AgoraRTC.Logger.setLogLevel(AgoraRTC.Logger.NONE);
    </script>

    <script data-script='StreamMixerInput'>
        class StreamMixerInput {
            constructor(stream, audioContext, mediaStreamDestination) {
                if(stream.getVideoTracks().length) {
                    this._alpha = 0;

                    this.video = document.createElement('video');
                    this.video.playsInline = true;
                    this.video.muted = true;
                    this.video.autoplay = true;
                    this.video.onloadedmetadata = () => this.updateVideoDimensions();
                    this.video.srcObject = stream;
                    this.video.play();

                    /*
                    window.addEventListener('load', event => {
                        this.video.style.display = 'none';
                        document.body.appendChild(this.video);
                    });
                    */

                    this.alphaTransitionTime = 250;

                    document.addEventListener('click', () => this.video.play(), {once: true});
                }

                if(stream.getAudioTracks().length) {
                    this.audioContext = audioContext;

                    this.mediaStreamSource = audioContext.createMediaStreamSource(stream);
                    
                    this.gainNode = audioContext.createGain();
                    this.gainNode.gain.value = 0;

                    this.gainTransitionTime = 0.1;

                    this.mediaStreamSource.connect(this.gainNode).connect(mediaStreamDestination);
                }
            }

            get hasVideo() {
                return Boolean(this.video);
            }

            get hasAudio() {
                return Boolean(this.mediaStreamSource);
            }

            get stream() {
                if(this.video)
                    return this.video.srcObject;
                else
                    return this.mediaStreamSource.mediaStream;
            }

            updateVideoDimensions() {
                if(this.video) {
                    const {width, height} = this.video.srcObject.getVideoTracks()[0].getSettings();
                    this.video.width = width;
                    this.video.height = height;
                }
            }

            get alpha() {
                return this._alpha;
            }
            set alpha(alpha) {
                if(alpha > 0)
                    delete this.__alpha;
                                
                if(!isNaN(this.intervalId)) {
                    this._alpha = this._alphaTarget;
                    delete this._alphaTarget;

                    if(this.isVideoMuted)
                        this.__alpha = this._alpha;

                    clearInterval(this.intervalId);
                    delete this.intervalId;
                }

                const now = Date.now();
                const fromAlpha = this.alpha;
                this._alphaTarget = alpha;
                this.intervalId = window.setInterval(() => {
                    const interpolation = ((Date.now() - now)/this.alphaTransitionTime);
                    const interpolatedAlpha = ((1-interpolation) * fromAlpha) + (interpolation * alpha);
                    this._alpha = Math.max(0, Math.min(1, interpolatedAlpha));
                    
                    if(interpolation >= 1) {
                        window.clearInterval(this.intervalId);
                        delete this.intervalId;
                    }
                }, 100);
            }

            muteVideo() {
                if(!this.isVideoMuted) {
                    this.__alpha = this.alpha;
                    this.alpha = 0;
                }
            }
            get isVideoMuted() {
                return !isNaN(this.__alpha);
            }
            unmuteVideo() {
                if(this.isVideoMuted) {
                    this.alpha = this.__alpha;
                    delete this.__alpha;
                }
            }

            draw(canvas, context) {
                if(this.video) {
                    context.save();

                    context.globalAlpha = this.alpha;
                    this.drawImage(canvas, context);

                    context.restore();
                }
            }

            drawImage(canvas, context) {
                if(this.alpha) {
                    const {width, height} = this.video.srcObject.getVideoTracks()[0].getSettings();
                    this.video.width = width;
                    this.video.height = height;
                    const shorterLength = Math.min(this.video.width, this.video.height);
                    const longerLength = Math.max(this.video.width, this.video.height);
                    const difference = longerLength - shorterLength;
                    
                    const isWide = this.video.width > this.video.height;
                    const offset = difference/2;
                    const x = isWide? offset:0;
                    const y = isWide? 0:offset;

                    context.drawImage(this.video, x, y, shorterLength, shorterLength, 0, 0, canvas.width, canvas.height);
                }
            }

            connect() {
                if(this.gainNode)
                    this.gainNode.connect(...arguments);
            }
            disconnect() {
                if(this.gainNode)
                    this.gainNode.disconnect(...arguments);
            }

            get gain() {
                if(this.gainNode)
                    return this.gainNode.gain.value;
            }
            set gain(gain) {
                if(this.gainNode) {
                    delete this.__gain;
                    this.gainNode.gain.value = gain;
                }
            }

            muteAudio() {
                if(!this.isAudioMuted) {
                    this.__gain = this.gain;
                    this.gain = 0;
                }
            }
            get isAudioMuted() {
                return !isNaN(this.__gain);
            }
            unmuteAudio() {
                if(this.isAudioMuted) {
                    this.gain = this.__gain;
                    delete this.__gain;
                }
            }

            remove() {
                this.disconnect();
                this.gain = 0;
                this.alpha = 0;

                if(this.video)
                    this.video.srcObject = null;
            }
        }
    </script>

    <script data-script='StreamMixer'>
        const _AudioContext = window.AudioContext || window.webkitAudioContext;
        let mixerView;
        class StreamMixer {
            constructor() {
                this.inputs = [];

                this._canvases = [];

                this.canvas = document.createElement('canvas');
                this.canvas.classList.add('video')
                this.canvasContext = this.canvas.getContext('2d');
                this.length = 200;

                /*
                window.addEventListener('load', event => {
                    this.canvas.style.display = 'none';
                    document.body.appendChild(this.canvas);
                });
                */

                this.audioContext = new _AudioContext();
                document.addEventListener('click', () => this.audioContext.resume(), {once: true});
                this.mediaStreamDestination = this.audioContext.createMediaStreamDestination();

                this.videoStream = this.canvas.captureStream(100);
                this.audioStream = this.mediaStreamDestination.stream;

                this.frameRate = 12;
                this.startDrawing();
            }

            get length() {
                return Math.max(this.canvas.width, this.canvas.height);
            }

            addCanvas(canvas) {
                canvas.width = canvas.height = this.canvas.length;
                this._canvases.push({
                    canvas,
                    context : canvas.getContext('2d'),
                });
            }
            removeCanvas(canvas) {
                const index = this._canvases.findIndex(_ => _.canvas == canvas);
                if(index >= 0)
                    this._canvases.splice(index, 1);
            }

            get videoInputs() {
                return this.inputs.filter(input => input.hasVideo);
            }
            
            get audioInputs() {
                return this.inputs.filter(input => input.hasAudio);
            }

            getInputByStream(stream) {
                return this.inputs.find(input => input.stream == stream);
            }

            get length() {
                return this._length;
            }
            set length(length) {
                const filter = this.canvasContext.filter;
                if(mixerView)
                    mixerView.setLength(length);
                this._length = length;
                this.canvas.width = this.canvas.height = length;
                this.canvasContext.filter = filter;
                this._canvases.forEach(_ => {
                    const {canvas, context} = _;
                    canvas.width = canvas.height = length;
                });
                this.draw();
            }

            get frameRate() {
                return this._frameRate;
            }
            set frameRate(frameRate) {
                this._frameRate = frameRate;

                if(this.isDrawing)
                    this.startDrawing();
            }

            startDrawing() {
                this.stopDrawing();
                this.intervalId = window.setInterval(() => {
                    this.draw();
                }, 1000/this.frameRate);
            }

            get isDrawing() {
                return !isNaN(this.intervalId);
            }

            draw() {
                this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.videoInputs.forEach(input => input.draw(this.canvas, this.canvasContext));
                //this.videoStream.getVideoTracks()[0].requestFrame();
                this._canvases.forEach(_ => {
                    const {canvas, context} = _;
                    context.drawImage(this.canvas, 0, 0);
                });
            }

            stopDrawing() {
                if(this.isDrawing) {
                    window.clearInterval(this.intervalId);
                    delete this.intervalId;
                }
            }

            addStream(stream) {
                let input = this.getInputByStream(stream);
                if(!input) {
                    input = new StreamMixerInput(stream, this.audioContext, this.mediaStreamDestination);
                    this.inputs.push(input);
                }
            }

            removeStream(stream) {
                let input = this.getInputByStream(stream);
                if(input) {
                    input.remove();
                    this.inputs.splice(this.inputs.indexOf(input), 1);
                }
            }

            setAlpha(stream, alpha) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.alpha = alpha;
            }
            setGain(stream, gain) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.gain = gain;
            }

            muteAudio(stream) {
                const input = this.getInputByStream(stream);
                if(input && input.hasAudio)
                    input.muteAudio();
            }
            unmuteAudio(stream) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.unmuteAudio();
            }

            muteVideo(stream) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.muteVideo();
            }
            unmuteVideo(stream) {
                const input = this.getInputByStream(stream);
                if(input)
                    input.unmuteVideo();
            }

            soloVideo(stream) {
                this.videoInputs.forEach(videoInput => {
                    if(videoInput.stream == stream)
                        videoInput.unmuteVideo();
                    else
                        videoInput.muteVideo();
                });
            }
            soloAudio(stream) {
                this.audioInputs.forEach(audioInput => {
                    if(audioInput.stream == stream)
                        audioInput.unmuteVideo();
                    else
                        audioInput.muteVideo();
                });
            }
            solo(stream) {
                this.soloVideo(stream);
                this.soloAudio(stream);
            }
        }
    </script>

    <script data-script='streamMixer'>
        const streamMixer = new StreamMixer();
    </script>

    <script data-script='channelName'>
        const url = new URL(window.location);
        const {searchParams} = url;
        let channelName = ' ';
        if(searchParams.has('channelName') && searchParams.get('channelName').length)
            channelName = searchParams.get('channelName');
    </script>

    <script data-script='appID'>
        const appID = '150d223019864b108fc38c6f37612e79';
        const client = AgoraRTC.createClient({mode: 'rtc', codec: 'vp8'});
    </script>

    <body>
        <style>
            #cover {
                width: 98%;
                height: 98%;
                background-color: white;
                position: absolute;
                z-index: 3;
                display: flex;
                align-items: center;
                text-align: center;
                font-size: 32px;;
                flex-direction: column;
                overflow: hidden;
                justify-content: center;
                user-select: none;
            }
        </style>
        <div id='cover'>
            Click to Join
        </div>

        <script data-script='cover'>
            const cover = document.querySelector('#cover');

            document.addEventListener('click', event => {
                cover.style.display = 'none';
            }, {once: true});
        </script>

        <style>
            #ui {
                display: flex;
                width: 100%; height: 100%;
                justify-content: center;
                align-items: center;
                align-content: center;
            }

            @media (min-aspect-ratio: 3/2) {#ui {flex-direction: row}}
            @media (max-aspect-ratio: 3/2) {#ui {flex-direction: column-reverse}}
        </style>
        
        <div id='ui' data-mirror>
            <style>
                #peers {
                    display: grid;
                    justify-content: center; align-items: center;
                    grid-auto-flow: dense;
                    flex: 1;
                }
                
                .peer, #activePeer {
                    position: relative;
                }

                #activePeer {
                    display: none;
                    grid-row: active-row;
                    grid-column: active-column;
                }

                .peer.mute-audio video, .peer.mute-audio canvas.video {filter: grayscale(100%)}

                .peer.mute-video video, .peer.mute-video canvas.video, #activePeer.mute-video video, #activePeer.mute-video canvas.video {
                    display: none;
                }

                #ui[data-mirror] #activePeer canvas, #ui[data-mirror] .peer canvas.video {
                    transform: scaleX(-1);
                }

                .peer, #activePeer {
                    width: 100%;
                    height: 100%;
                }
                .peer video, #activePeer video, .peer canvas.video, #activePeer canvas.video {
                    width: 100%;
                    height: 100%;
                    object-fit: contain !important;
                }

                #activePeer:not([data-canvas]) canvas.video {
                    display: none;
                }
                #activePeer[data-canvas] video {
                    display: none;
                }

                canvas.waveform {
                    position: absolute; z-index: 2;
                    width: 100%;
                    height: 20%;
                    bottom: 0;
                    -webkit-mask-image: linear-gradient(to right, transparent, black, transparent);
                    mask-image: linear-gradient(to right, transparent, black, transparent);
                }
            </style>

            <div id='peers'>
                <div id='activePeer' data-video>
                    <canvas class='waveform'></canvas>
                    <video autoplay playsinline muted></video>
                    <canvas class='video'></canvas>
                </div>
                <template>
                    <div class='peer'>
                        <canvas class='waveform'></canvas>
                    </div>
                </template>
            </div>

            <script data-script='peers'>
                const streams = [];

                const activePeer = document.querySelector('#activePeer');
                //activePeer.addEventListener('click', event => onPeerActive());

                const peers = document.querySelector('#peers');
                const peerTemplate = document.querySelector(`#peers template`);

                const getPeer = (id) => {
                    return document.querySelector(`[data-id="${id}"].peer`);
                }
                const addPeer = (_stream) => {
                    document.addEventListener('click', event => {
                        _stream.getAudioLevel();
                        _stream.audioLevelHelper.audioContext.resume();
                    }, {once: true});
                    
                    _stream.getAudioLevel();
                    //_stream.audioLevelHelper.analyser.fftSize = 2**8;
                    streams.push(_stream);
                    const peer = peerTemplate.content.cloneNode(true).querySelector('.peer');

                    const id = _stream.getId();
                    peer.dataset.id = id;
                    peer.style.order = id.toString().substr(0, 9);
                    peer.id = id.toString();

                    const removePeer = () => {
                        if(streams.includes(_stream)) {
                            streams.splice(streams.indexOf(_stream), 1);
                        }
                        peer.remove();

                        if(activePeer.dataset.id == id) {
                            onPeerActive();
                        }
                        else {
                            onPeerActive(activePeer.dataset.id);
                        }

                        window.dispatchEvent(new Event('resize'));
                    }

                    _stream.stream.oninactive = () => removePeer();

                    peers.appendChild(peer);
                    if(_stream !== stream) {
                        _stream.play(id.toString(), {fit:'contain'});
                        
                        document.addEventListener('click', event => {
                            const audio = peer.querySelector('audio');
                            if(audio) {
                                audio.muted = false;
                                audio.play();
                            }
                        });

                        peer.addEventListener('click', event => {
                            //onPeerActive(id);
                        });
                    }
                    else {
                        peer.appendChild(streamMixer.canvas);

                        peer.addEventListener('click', event => {
                            const videoInput = streamMixer.videoInputs.find(videoInput => !videoInput.isVideoMuted);
                            if(videoInput && streamMixer.videoInputs.length > 1) {
                                const index = streamMixer.videoInputs.indexOf(videoInput);
                                /*
                                const nextIndex = (streamMixer.videoInputs.length == index+1)?
                                    0 :
                                    index+1;
                                */
                                const nextIndex = (index+1) % streamMixer.videoInputs.length;
                                const nextVideoInput = streamMixer.videoInputs[nextIndex];
                                streamMixer.soloVideo(nextVideoInput.stream);
                                if(mixerView) {
                                    const mixerStream = mixerStreams.find(mixerStream => mixerStream.stream == nextVideoInput.stream);
                                    if(mixerStream)
                                        mixerView.setStreamId(mixerStream.getId());
                                    
                                }
                            }
                        });
                    }

                    window.dispatchEvent(new Event('resize'));

                    if(id == activePeer.dataset.id)
                        onPeerActive(id);
                }

                client.on('stream-added', event => client.subscribe(event.stream));
                client.on('stream-subscribed', event => addPeer(event.stream));
                client.on('peer-leave', event => {
                    if(!MediaStream.prototype.hasOwnProperty('oninactive')) {
                        const id = event.uid;
                        const stream = streams.find(stream => stream.getId() == id);
                        if(stream)
                            stream.stream.oninactive();
                    }
                });
                
                const onPeerMuteAudio = (id) => {
                    const peer = getPeer(id);
                    peer.classList.add('mute-audio');
                    if(activePeer.dataset.id == id) {
                        onPeerActive();
                    }
                }
                client.on('mute-audio', event => onPeerMuteAudio(event.uid));

                const onPeerUnmuteAudio = (id) => {
                    const peer = getPeer(id);
                    peer.classList.remove('mute-audio');
                }
                client.on('unmute-audio', event => onPeerUnmuteAudio(event.uid));

                const onPeerMuteVideo = (id) => {
                    const peer = getPeer(id);
                    const video = peer.querySelector('video');
                    peer.classList.add('mute-video');
                    if(activePeer.dataset.id == id) {
                        activePeer.classList.add('mute-video')
                    }
                }
                client.on('mute-video', event => onPeerMuteVideo(event.uid));

                const onPeerUnmuteVideo = (id) => {
                    const peer = getPeer(id);
                    const video = peer.querySelector('video');
                    peer.classList.remove('mute-video');
                    if(activePeer.dataset.id == id) {
                        activePeer.classList.remove('mute-video')
                    }
                }
                client.on('unmute-video', event => onPeerUnmuteVideo(event.uid));

                let switchingActivePeer = false;
                const onPeerActive = (id) => {                    
                    if(switchingActivePeer) return;
                    switchingActivePeer = true;

                    const peer = getPeer(id);
                    const _stream = streams.find(stream => stream.getId() == id);

                    const video = activePeer.querySelector('video');
                    const canvas = activePeer.querySelector('canvas.video');

                    if(peer && _stream && streams.length >= 3) {
                        if(peer.classList.contains('mute-video'))
                            activePeer.classList.add('mute-video')
                        else
                            activePeer.classList.remove('mute-video');

                        if(id == activePeer.dataset.id) {
                            if(stream == _stream) {
                                streamMixer.addCanvas(canvas);
                                activePeer.dataset.canvas =  '';
                                video.srcObject = null;
                            }
                            else {
                                streamMixer.removeCanvas(canvas);
                                video.srcObject = _stream.stream;
                                delete activePeer.dataset.canvas;
                            }
                        }



                        activePeer.style.display = 'inherit';
                        activePeer.dataset.id = id;
    
                        window.dispatchEvent(new Event('resize'));
                    }
                    else {
                        if(streams.length < 3) {
                            video.srcObject = null;
                            streamMixer.removeCanvas(canvas);

                            activePeer.style.display = '';
                            activePeer.removeAttribute('data-id');
                        }
                        else {
                            // 
                        }
                    }

                    switchingActivePeer = false;
                }

                let audioLevelIntervalId;
                const waveforms = {};
                const period = 0.5;
                const numberOfWaveformSamples = 50;
                document.addEventListener('click', event => {
                    audioLevelIntervalId = setInterval(() => {
                        streams.forEach(stream => {
                            let waveform = waveforms[stream.getId()];
                            if(!waveform) {
                                waveform = waveforms[stream.getId()] = new Array(0);
                                waveform.fill(0);
                            }

                            const audioLevel = stream.getAudioLevel();
                            console.log(audioLevel);

                            waveform.push(audioLevel);
                            if(waveform.length > numberOfWaveformSamples)
                                waveform.shift();
                        });
                    }, period*1000/numberOfWaveformSamples);
                }, {once: true});

                const renderWaveformLoop = () => {
                    streams.forEach(stream => {
                        const peer = getPeer(stream.getId());
                        const waveform = waveforms[stream.getId()];

                        if(peer && waveform) {
                            const canvas = peer.querySelector('canvas');
                            const context = canvas.getContext('2d');

                            const sampleWidth = canvas.width/numberOfWaveformSamples;
                            context.clearRect(0, 0, canvas.width, canvas.height);

                            context.fillStyle = 'green';
                            waveform.forEach((sample, index) => {
                                const sampleHeight = sample * canvas.height;

                                const sampleX = (index*sampleWidth);
                                const sampleY = canvas.height*(0.5 - (sample/2));
    
                                context.fillRect(sampleX, sampleY, sampleWidth, sampleHeight);
                            });

                            if(activePeer.dataset.id == stream.getId()) {
                                const _canvas = activePeer.querySelector('canvas');
                                const _context = _canvas.getContext('2d');

                                _context.clearRect(0, 0, _canvas.width, _canvas.height);
                                _context.drawImage(_canvas, 0, 0);
                            }
                        }
                    });
                    window.requestAnimationFrame(renderWaveformLoop);
                }

                const renderWaveformLoopIntervalId = window.requestAnimationFrame(renderWaveformLoop);
            </script>

            <script data-script='croquet-active-speaker'>
                class ChatModel extends Croquet.Model {
                    init({channelName}) {
                        super.init();

                        this.channelName = channelName;
                        this.subscribe('active-speaker', 'set', this.onSetActiveSpeaker);
                    }

                    onSetActiveSpeaker({activeSpeakerId}) {
                        if(this.activeSpeakerId !== activeSpeakerId) {
                            this.activeSpeakerId = activeSpeakerId;
                            this.publish('active-speaker', 'update');
                        }
                    }
                }
                ChatModel.register();

                class ChatView extends Croquet.View {
                    constructor(model) {
                        super(model);
                        this.model = model;

                        this.subscribe('active-speaker', 'update', this.onUpdateActiveSpeaker);
                        this.onUpdateActiveSpeaker();
                    }

                    onUpdateActiveSpeaker() {
                        onPeerActive(this.model.activeSpeakerId);
                    }

                    setActiveSpeaker(activeSpeakerId) {
                        if(this.model.activeSpeakerId !== activeSpeakerId)
                            this.publish('active-speaker', 'set', {activeSpeakerId});
                    }
                }

                Croquet.App.root = false;

                let view;
                if(false) {
                    Croquet.startSession('zakchat', ChatModel, ChatView, {
                        options : {channelName},
                    }).then(session => {
                        view = session.view;
                        client.on('active-speaker', event => view.setActiveSpeaker(event.uid));
                        view.onUpdateActiveSpeaker();
                    });
                }
                else {
                    setInterval(() => {
                        if(true || streams.length >= 3) {
                            const levels = streams.map(stream => stream.getAudioLevel());
                            let maxIndex = 0;
                            let maxLevel = 0;
                            levels.forEach((level, index) => {
                                if(level > maxLevel) {
                                    maxLevel = level;
                                    maxIndex = index;
                                }
                            });
    
                            if(maxLevel > 0.35)
                                onPeerActive(streams[maxIndex].getId());
                        }
                    }, 200);
                }

                //client.on('active-speaker', event => onPeerActive(event.uid));
            </script>

            <script data-script='clientInit'>
                let stream;
                client.init(appID, () => {
                    client.join(null, channelName, null, id => {
                        stream = AgoraRTC.createStream({
                            streamID: id,

                            audio: true,
                            audioSource : streamMixer.audioStream.getAudioTracks()[0],

                            video: true,
                            videoSource: streamMixer.videoStream.getVideoTracks()[0],

                            mirror: true,
                        });

                        stream.init(() => {
                            client.publish(stream, error => console.error(error));
                            addPeer(stream);
                        }, error => console.error(error));
                    });
                });
            </script>

            <script data-script='resizePeers'>
                window.addEventListener('resize', event => {
                    let {width} = window.getComputedStyle(ui);
                    let {height} = window.getComputedStyle(ui);

                    width = Number(width.replace('px', ''));
                    height = Number(height.replace('px', ''));

                    if(getComputedStyle(ui).flexDirection.includes('row'))
                        width = Math.max(0, width-120);
                    else
                        height = Math.max(0, height-120);

                    const aspectRatio = width/height;

                    let rows = 1;
                    let columns = 1;

                    let gridTemplateColumns = ``;
                    let gridTemplateRows = ``;

                    const numberOfPeers = peers.querySelectorAll('.peer:not(template)').length;

                    if(getComputedStyle(activePeer).display !== 'none') {
                        let activeSize = 2;

                        while(numberOfPeers > ((rows*columns) - activeSize**2)) {
                            const aspectRatios = {
                                row : Math.abs(aspectRatio - columns/(rows+1)),
                                column : Math.abs(aspectRatio - (columns+1)/rows),
                            };

                            if(aspectRatios.row < aspectRatios.column)
                                rows++
                            else
                                columns++;
                            
                            activeSize = Math.max(2, Math.min(rows, columns)-2)
                        }

                        const leftColumns = Math.floor((columns - activeSize)/2);
                        const rightColumns = Math.ceil((columns - activeSize)/2);
                        if(leftColumns) gridTemplateColumns += `repeat(${leftColumns}, 1fr) `;
                        gridTemplateColumns += ` [active-column-start] repeat(${activeSize}, 1fr) [active-column-end] `;
                        if(rightColumns) gridTemplateColumns += `repeat(${rightColumns}, 1fr) `;

                        const topRows = Math.floor((rows - activeSize)/2);
                        const bottomRows = Math.ceil((rows - activeSize)/2);
                        if(topRows) gridTemplateRows += `repeat(${topRows}, 1fr) `;
                        gridTemplateRows += ` [active-row-start] repeat(${activeSize}, 1fr) [active-row-end] `;
                        if(bottomRows) gridTemplateRows += `repeat(${bottomRows}, 1fr) `;
                    }
                    else {    
                        while(numberOfPeers > rows*columns) {
                            const aspectRatios = {
                                row : Math.abs(aspectRatio - columns/(rows+1)),
                                column : Math.abs(aspectRatio - (columns+1)/rows),
                            };

                            if(aspectRatios.row < aspectRatios.column)
                                rows++
                            else
                                columns++;
                        }

                        gridTemplateColumns = `repeat(${columns}, 1fr)`;
                        gridTemplateRows = `repeat(${rows}, 1fr)`;
                    }

                    const length = Math.floor(Math.min(width/columns, height/rows));
                    if(streamMixer) {
                        const _length = Math.floor(Math.sqrt((1280*720)/numberOfPeers));
                        document.querySelectorAll('canvas.waveform').forEach(canvas => {
                            canvas.width = _length;
                            canvas.height = _length*0.2;
                        });
                        streamMixer.length = Math.max(32, Math.min(_length, 200));
                    }
                    const lengthString = `${length}px`;

                    gridTemplateColumns = gridTemplateColumns.replace(/1fr/g, lengthString);
                    gridTemplateRows = gridTemplateRows.replace(/1fr/g, lengthString);
                    
                    peers.style.gridTemplateRows = gridTemplateRows;
                    peers.style.gridTemplateColumns = gridTemplateColumns;
                });

                window.dispatchEvent(new Event('resize'));
            </script>

            <style>
                #controls {
                    flex-basis: 120px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    
                }

                #controls > * {
                    order : 1;
                }

                @media (min-aspect-ratio: 3/2) {#controls {flex-direction: column; max-width: 120px}}
                @media (max-aspect-ratio: 3/2) {#controls {flex-direction: row; max-height: 120px}}
            </style>

            <div id='controls'>
                <style>
                    #controls > div[data-control] {
                        width: 100px;
                        height: 100px;
                        border-radius: 50%;
                        overflow: hidden;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        border: solid black;
                        user-select: none;
                        max-width: 100px;
                        max-height: 100px;
                        flex: 1;
                    }

                    @media (min-aspect-ratio: 3/2) {#controls > div[data-control]:not(:nth-of-type(3)) {margin-bottom: 15px}}
                    @media (max-aspect-ratio: 3/2) {#controls > div[data-control]:not(:nth-of-type(3)) {margin-right: 15px}}
                </style>
                <div data-control='muteAudio' onclick='muteAudio()'>mute</div>
                <div data-control='muteVideo' onclick='muteVideo()'>hide</div>
                <div data-control='settings' onclick='toggleSettings()'>settings</div>
                
                <script data-script='controls'>
                    const muteAudioButton = document.querySelector(`#controls [data-control="muteAudio"]`);
                    const muteVideoButton = document.querySelector(`#controls [data-control="muteVideo"]`);
                    const settingsButton = document.querySelector(`#controls [data-control="settings"]`);
                    
                    const muteAudio = (muted, trigger = true) => {
                        const id = stream.getId();
                        if(stream) {
                            if((muted == undefined && stream.isAudioOn()) || muted == true) {
                                stream.muteAudio();
                                streamMixer.canvasContext.filter = 'grayscale(100%)';
                                onPeerMuteAudio(id);
                            }
                            else if((muted == undefined && !stream.isAudioOn()) || muted == false) {
                                stream.unmuteAudio();
                                if(trigger)
                                    testAudio(true);
                                streamMixer.canvasContext.filter = 'none';
                                onPeerUnmuteAudio(id);
                            }

                            muteAudioButton.innerText = stream.isAudioOn()?
                                'mute':
                                'unmute';
                        }
                    };

                    const muteVideo = (muted) => {
                        if(stream) {
                            const id = stream.getId();
                            if((muted == undefined && stream.isVideoOn()) || muted == true) {
                                stream.muteVideo();
                                onPeerMuteVideo(id);
                            }
                            else if((muted == undefined && !stream.isVideoOn()) || muted == false) {
                                stream.unmuteVideo();
                                onPeerUnmuteVideo(id);
                            }
                            
                            muteVideoButton.innerText = stream.isVideoOn()?
                                'hide':
                                'show';
                        }
                    };

                    const toggleSettings = (hidden) => {
                        if((hidden == undefined && !controls.hasAttribute('data-settings')) || hidden == false) {
                            controls.dataset.settings = '';
                            settingsButton.innerText = 'hide settings';
                        }
                        else if((hidden == undefined && controls.hasAttribute('data-settings')) || hidden == true) {
                            delete controls.dataset.settings;
                            settingsButton.innerText = 'settings';
                        }
                    }

                    const testAudio = (muted, trigger = true) => {
                        outputAudio.muted = (muted == undefined)?
                            !outputAudio.muted :
                            muted;
                        
                        if(trigger)
                            muteAudio(!outputAudio.muted, false);

                        testAudioButton.innerText = outputAudio.muted?
                            'test audio':
                            'stop testing audio';              
                    };
                </script>

                <style>
                    /*#output video.mute-audio {filter: grayscale(100%)}*/
                    #output {
                        /* display: flex; */
                        display: none;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        align-content: center;
                    }
                    #output video {
                        align-self: center;
                        flex: 1;
                    }
                    #output audio {
                        display: hidden;
                    }
                </style>

                <div id='output'>
                    <video width='100' height='100' autoplay playsinline muted></video>
                    <audio autoplay playsinline muted></audio>
                </div>

                <script data-script='output'>
                    //const outputVideo = document.querySelector('#output video');
                    const outputAudio = document.querySelector(`#output audio`);
                    //outputVideo.srcObject = streamMixer.videoStream;
                    outputAudio.srcObject = streamMixer.audioStream.clone();

                    document.addEventListener('click', () => {/*outputVideo.play();*/ outputAudio.play()}, {once: true});
                </script>

                <style>
                    #gain {
                        /*display: flex;*/
                        display: none;
                        flex-direction: column;
                        max-width: inherit;
                        max-height: inherit;
                    }
                    #controls[data-settings] > #gain {
                        display: flex;
                    }
                    @media (min-aspect-ratio: 3/2) {#gain {

                    }}
                    @media (max-aspect-ratio: 3/2) {#gain {

                    }}

                    #gainLabel {
                        text-align: center;
                        -webkit-user-select: none;
                    }

                    #gainInput {

                    }
                    @media (min-aspect-ratio: 3/2) {#gainInput {width: 100%;}}
                    @media (max-aspect-ratio: 3/2) {#gainInput {
                        -webkit-appearance: slider-vertical;
                        writing-mode: bt-lr;
                        height: 80px;
                    }}
                </style>

                <div id='gain'>
                    <span id='gainLabel'>Volume</span>
                    <input id='gainInput' type='range' min='0' max='2' step='0.01' value='1'>
                </div>

                <script data-script='gainInput'>
                    const gainInput = document.querySelector('#gainInput');
                    gainInput.addEventListener('input', event => {
                        const gain = Number(event.target.value);
                        streamMixer.audioInputs.forEach(audioInput => audioInput.gain = gain);
                    });
                </script>

                <style>
                    #inputControls {
                        /*display: flex;*/
                        display: none;
                        flex-direction: column;
                        max-width: inherit;
                        max-height: inherit;
                    }
                    #controls[data-settings] > #inputControls {
                        display: flex;
                    }
                </style>
                
                <div id='inputControls'>
                    <style>
                        #inputControls select {
                            text-overflow: ellipsis;
                            max-width: 120px;
                        }

                        #inputControls button {
                            flex: 1;
                        }

                        @media (min-aspect-ratio: 3/2) {#buttons {
                            flex-direction: column;
                        }}
                        @media (max-aspect-ratio: 3/2) {#buttons {
                            flex-direction: column;
                        }}
                    </style>

                    <select id='videoSelect'></select>
                    <select id='audioSelect'></select>
                    <button style='z-index: 3' id='testAudio' onclick='testAudio()'>test audio</button>
                    <button id='qrCodeToggle' onclick='toggleQRCode()'>show camera QR</button>

                    <script data-script='inputSelects'>
                        const localStreams = {};

                        let mixerStream;

                        const videoSelect = document.querySelector(`#videoSelect`);
                        videoSelect.addEventListener('change', event => {
                            let deviceId = event.target.value;
                            if(deviceId == '')
                                deviceId = true;

                            navigator.mediaDevices.getUserMedia({video: {deviceId}})
                                .then(stream => {
                                    if(localStreams.video) {
                                        streamMixer.removeStream(localStreams.video);
                                        stopStream(localStreams.video);
                                        delete localStreams.video;
                                    }
                                    localStreams.video = stream;

                                    if(!mixerStream) {
                                        mixerStream = AgoraRTC.createStream({
                                            audio: false,

                                            video: true,
                                            cameraId: videoSelect.value,
                                            mirror: true,
                                        });
                                        mixerStreams.push(mixerStream);

                                        mixerStream.init(() => {
                                            if(mixerClient)
                                                mixerClient.publish(mixerStream, error => console.error(error));
                                            
                                            addInput(mixerStream);
                                            
                                            if(window.mixerView)
                                                mixerView.setStreamId(mixerStream.getId());

                                        }, error => console.error(error));
                                    }
                                    else {
                                        mixerStream.switchDevice('video', videoSelect.value, () => {

                                        }, error => {
                                            console.error(error);
                                        });
                                    }
                                });
                        });
    
                        const audioSelect = document.querySelector(`#audioSelect`);
                        audioSelect.addEventListener('change', event => {
                            let deviceId = event.target.value;
                            if(deviceId == '')
                                deviceId = true;

                            navigator.mediaDevices.getUserMedia({audio: {deviceId}})
                                .then(stream => {
                                    if(localStreams.audio) {
                                        streamMixer.removeStream(localStreams.audio);
                                        stopStream(localStreams.audio);
                                        delete localStreams.audio;
                                    }

                                    streamMixer.addStream(stream);
                                    streamMixer.setGain(stream, 1);
                                    localStreams.audio = stream;
                                });
                        });

                        const testAudioButton = document.querySelector('button#testAudio');

                    </script>
                </div>

                <script data-script='mediaDevices'>
                    const stopStream = stream => stream.getTracks().forEach(track => track.stop());
                    const getCameraAccess = () => navigator.mediaDevices.getUserMedia({video: true, audio: true}).then(stream => stopStream(stream));

                    let updatingdevices = false;
                    const ondevicechange = () => {
                        if(updatingdevices) return;
                        updatingdevices = true;

                        videoSelect.innerHTML = audioSelect.innerHTML = '';

                        return navigator.mediaDevices.enumerateDevices().then(devices => devices.filter(device => device.kind.includes('input'))).then(outputDevices => {
                            outputDevices.forEach(device => {
                                const {kind, deviceId, label} = device;
                                const option = new Option(label, deviceId);
                                const select = kind.includes('video')? videoSelect:audioSelect;
                                select.appendChild(option);
                            });
                        }).then(() => {
                            if(!localStreams.video) {
                                videoSelect.dispatchEvent(new Event('change'));
                            }

                            if(!localStreams.audio) {
                                audioSelect.dispatchEvent(new Event('change'));
                            }

                            updatingdevices = false;
                        });
                    }
                    navigator.mediaDevices.addEventListener('devicechange', () => ondevicechange());
                    document.addEventListener('click', event => getCameraAccess().then(() => ondevicechange()), {once: true});
                </script>

                <!--
                <style>
                    #inputVideos {
                        display: none;
                        /* display: grid; */
                        justify-content: center; align-items: center;
                        grid-auto-flow: dense;
                        flex: 1;
                        max-width: inherit; max-height: inherit;
                    }

                    @media (min-aspect-ratio: 3/2) {#inputVideos {width: 100%}}
                    @media (max-aspect-ratio: 3/2) {#inputVideos {height: 100%}}

                    #inputVideos .inputVideo {
                        object-fit: contain;
                        width: 100%; height: 100%;
                    }

                    #inputVideos .inputVideo video {
                        width: 100%; height: 100%;
                        object-fit: contain;
                    }
                </style>

                <div id='inputVideos'>
                    <template>
                        <div class='inputVideo'>
                            <video width='100' height='100' autoplay playsinline muted></video>
                        </div>
                    </template>
                </div>
                -->

                <script data-script='inputVideos'>
                    //const inputVideos = document.querySelector('#inputVideos');
                    //const inputVideoTemplate = inputVideos.querySelector('template');

                    const addInput = (stream) => {
                        //const inputVideo = inputVideoTemplate.content.cloneNode(true).querySelector('.inputVideo');
                        //const video = inputVideo.querySelector('video');
                        //video.srcObject = stream.stream;

                        if(stream !== mixerStream)
                            mixerStreams.push(stream);

                        /*
                        video.addEventListener('click', event => {
                            streamMixer.soloVideo(stream.stream);
                        });
                        */

                        streamMixer.addStream(stream.stream);
                        streamMixer.setAlpha(stream.stream, 1);
                        streamMixer.soloVideo(stream.stream);
                        if(mixerView)
                            mixerView.setStreamId(stream.getId());

                        const removeInput = () => {
                            if(stream == mixerStream) return;

                            if(mixerStreams.includes(stream))
                                mixerStreams.splice(mixerStreams.indexOf(stream), 1);

                            //inputVideo.remove();
                            streamMixer.removeStream(stream.stream);

                            if(streamMixer.videoInputs.every(videoInput => videoInput.isVideoMuted)) {
                                const videoInput = streamMixer.videoInputs[0];
                                if(videoInput)
                                    videoInput.unmuteVideo();
                            }

                            window.dispatchEvent(new Event('resize'));
                        }
                        
                        stream.stream.oninactive = () => removeInput();

                        //inputVideos.appendChild(inputVideo);

                        window.dispatchEvent(new Event('resize'));
                    };
                </script>

                <script data-script='mixerClient'>
                    const mixerChannelName = Math.random().toString().split('.')[1].substr(0, 4);
                    const mixerStreams = [];

                    const mixerClient = AgoraRTC.createClient({mode: 'rtc', codec: 'vp8'});

                    mixerClient.init(appID, () => {
                        mixerClient.join(null, mixerChannelName, null, id => {
                            
                        });
                    });

                    mixerClient.on('stream-added', event => mixerClient.subscribe(event.stream));
                    mixerClient.on('stream-subscribed', event => addInput(event.stream));
                    mixerClient.on('peer-leave', event => {
                        if(!MediaStream.prototype.hasOwnProperty('onpeerinactive')) {
                            const id = event.uid;
                            const stream = mixerStreams.find(stream => stream.getId() == id);
                            if(stream)
                                stream.stream.oninactive();
                        } 
                    });
                </script>

                <script data-script='inputVideosResize'>
                    /*
                    window.addEventListener('resize', event => {
                        let {width} = window.getComputedStyle(inputVideos);
                        let {height} = window.getComputedStyle(inputVideos);

                        width = Number(width.replace('px', ''));
                        height = Number(height.replace('px', ''));

                        const aspectRatio = width/height;

                        let rows = 1;
                        let columns = 1;

                        let gridTemplateColumns = ``;
                        let gridTemplateRows = ``;

                        const numberOfInputs = inputVideos.querySelectorAll('.inputVideo:not(template)').length;

                        while(numberOfInputs > rows*columns) {
                            const aspectRatios = {
                                row : Math.abs(aspectRatio - columns/(rows+1)),
                                column : Math.abs(aspectRatio - (columns+1)/rows),
                            };

                            if(aspectRatios.row < aspectRatios.column)
                                rows++
                            else
                                columns++;
                        }

                        gridTemplateColumns = `repeat(${columns}, 1fr)`;
                        gridTemplateRows = `repeat(${rows}, 1fr)`;

                        const length = Math.floor(Math.min(width/columns, height/rows));
                        const lengthString = `${length}px`;
                        //gridTemplateColumns = gridTemplateColumns.replace(/1fr/g, lengthString);
                        //gridTemplateRows = gridTemplateRows.replace(/1fr/g, lengthString);
                        
                        inputVideos.style.gridTemplateRows = gridTemplateRows;
                        inputVideos.style.gridTemplateColumns = gridTemplateColumns;
                    });

                    window.dispatchEvent(new Event('resize'));
                    */
                </script>

                <script data-script='croquet'>
                    class MixerModel extends Croquet.Model {
                        init({channelName, mixerChannelName}) {
                            super.init();
                            this.streamId = null;

                            this.mirror = {};

                            this.channelName = channelName;
                            this.mixerChannelName = mixerChannelName;
                            
                            this.length = 200;

                            this.subscribe(this.sessionId, 'setMirror', this.setMirror);
                            this.subscribe(this.sessionId, 'setStreamId', this.setStreamId);
                            this.subscribe(this.sessionId, 'setLength', this.setLength);
                        }

                        setStreamId({streamId}) {
                            this.streamId = streamId;
                            this.publish(this.sessionId, 'onUpdateStreamId');
                        }

                        setLength({length}) {
                            this.length = length;
                            this.publish(this.sessionId, 'onUpdateLength');
                        }

                        setMirror({streamId, mirror}) {
                            if(streamId == undefined) return;

                            this.mirror[streamId] = mirror;
                            this.publish(this.sessionId, 'onUpdateMirror');
                        }
                    }
                    MixerModel.register();

                    class MixerView extends Croquet.View {
                        constructor(model) {
                            super(model);
                            this.model = model;

                            this.subscribe(this.sessionId, 'onUpdateStreamId', this.onUpdateStreamId);
                            this.subscribe(this.sessionId, 'onUpdateMirror', this.onUpdateMirror);
                            if(mixerStream)
                                this.setStreamId(mixerStream.getId());
                        }

                        setStreamId(streamId) {
                            this.publish(this.sessionId, 'setStreamId', {streamId});
                        }

                        setLength(length) {
                            this.publish(this.sessionId, 'setLength', {length});
                        }

                        onUpdateStreamId() {
                            const _mixerStream = mixerStreams.find(mixerStream => mixerStream.getId() == this.model.streamId);
                            const currentVideoInput = streamMixer.videoInputs.find(videoInput => !videoInput.isVideoMuted);
                            if(_mixerStream && currentVideoInput && _mixerStream.stream !== currentVideoInput.stream) {
                                streamMixer.soloVideo(_mixerStream.stream);
                            }
                            this.onUpdateMirror();
                        }

                        onUpdateMirror() {
                            const mirror = this.model.mirror[this.model.streamId];
                            const ui = document.querySelector('#ui');

                            if(mirror == undefined || mirror == true)
                                ui.dataset.mirror = '';
                            else
                                ui.removeAttribute('data-mirror');
                        }
                    }

                    Croquet.App.root = false;
                    Croquet.startSession(`agora.io-mixer`, MixerModel, MixerView, {options: {channelName, mixerChannelName}})
                        .then(session => {
                            const {view} = session;
                            mixerView = view;
                        });
                </script>

            </div>

            <script data-script='controls'>
                const controls = document.querySelector('#controls');
            </script>
        </div>

        <style>
            #qrcode {
                position: absolute;
                left: 20;
                top: 20;

                z-index: 2;

                display: none;
                border: solid white 10px;
            }
        </style>

        <a id='qrcode' target='_blank'></a>

        <script data-script='qrcode'>
            const qrcode = document.querySelector('#qrcode');

            const qrcodeURL = `https://${location.host}/c?c=${channelName}&m=${mixerChannelName}`;
            new QRCode(qrcode, {
                text: qrcodeURL,
                width: 300,
                height: 300,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.H,
            });
            qrcode.href = qrcodeURL;
            qrcode.title = '';

            document.addEventListener('click', event => {
                if(qrcode.style.display == 'block' && event.target.id !== 'qrCodeToggle')
                    toggleQRCode(true);
            });

            const toggleQRCode = (hidden) => {
                if((hidden == undefined && qrcode.style.display == '') || hidden == false) {
                    qrcode.style.display = 'block';
                    qrCodeToggle.innerText = 'hide camera QR';
                }
                else if((hidden == undefined && qrcode.style.display == 'block') || hidden == true) {
                    qrcode.style.display = '';
                    qrCodeToggle.innerText = 'show camera QR';
                }
            }
        </script>
    </body>
</html>